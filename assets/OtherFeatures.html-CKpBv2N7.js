import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as i,c as u,a as n,b as s,d as a,w as p,e as t}from"./app-BX3Xhc_b.js";const r="/assets/OtherFeatures-1-DfSvXOxs.png",d={},k=n("h1",{id:"其他特性",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#其他特性"},[n("span",null,"其他特性")])],-1),h=n("p",null,"这里将列举一些编程语言的其他特性，它们不如那些单独开章节的特性那样基础和常用，故只做简单的介绍（我自己了解的也不深）。",-1),m=n("h2",{id:"协程",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#协程"},[n("span",null,"协程")])],-1),_=n("br",null,null,-1),b=n("br",null,null,-1),v={style:{"text-align":"right"}},f={href:"https://github.com/Cpp-Club/Cxx_HOPL4_zh/blob/main/09.md",target:"_blank",rel:"noopener noreferrer"},g=n("p",null,[s("我认为对协程最好的解释是“可恢复函数”，虽然实现时需要保存状态信息（栈帧）使得它更像一个对象而并非函数。这里从"),n("strong",null,"作用"),s("和"),n("strong",null,"设计"),s("两个角度描述它。")],-1),C=n("p",null,"协程可以用于：异步IO处理，延时任务，步长GC，生成器/迭代器（在python和科学运算领域很常见）",-1),w=n("p",null,"协程按设计可以分为：有栈协程和无栈协程，有栈协程比无栈协程更通用（但速度较慢）[参考：Cxx_HOPL4]。",-1),x=n("blockquote",null,[n("p",null,"有栈协程和无栈协程的区别主要在于协程的执行栈是由谁分配和管理的。在有栈协程中，操作系统为每个协程分配一个固定大小的栈空间，由协程自己管理和使用。在无栈协程中，协程的执行栈是动态分配的，可以在运行时根据需要进行扩展或收缩，也可以与其他协程共享同一个栈空间。")],-1),y=n("code",null,"async/await",-1),E={href:"https://book.douban.com/subject/26285940",target:"_blank",rel:"noopener noreferrer"},L=n("li",null,"有栈协程：而反观有栈协程，更像是一种在用户态模拟的线程，同样以栈的方式存储其嵌套调用的函数信息，通过完整的调用栈来满足“可恢复”这一特性。",-1),A=t('<p>我的理解：从定义上看感觉有栈协程的调度更简单些，有栈协程因为有调用栈，随时都可以暂停，而无栈协程要等到它运行到下一个状态才可以。相对的，有栈协程每次调度都需要将上下文切换到调用栈，调用栈的大小肯定是比单个状态大很多的。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h2><p>无论是C++的函数对象、C#的委托、Lua的function还是各种lambda匿名函数，都能看到闭包的身影。闭包的定义如下：</p><blockquote><p>“闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如C++）。”</p></blockquote><p>C++中的闭包是比较直观的，因为其实现原理很容易解释清楚。而lua的闭包则相对难以理解，因为其并不是由编译器生成一个xx结构来完成的。</p><h3 id="c-的闭包" tabindex="-1"><a class="header-anchor" href="#c-的闭包"><span>C++的闭包</span></a></h3><p>C++在 <code>C++11</code> 之后支持闭包，通过将lambda表达式转换为函数对象的方式（在<code>[]</code>中表示闭包的捕获），如下方代码所示的，<code>main</code> 函数中定义的局部变量 <code>func1</code> 的左边部分经过编译后会产生一个和 <code>test</code> 结构体等价的函数对象。</p>',7),B={href:"https://hackingcpp.com/cpp/lang/separate_compilation.html",target:"_blank",rel:"noopener noreferrer"},q=t(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">test</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">;</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">+</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> func1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 指定隐式引用捕获（编译器负责推导）</span>
        cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">+</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> func2 <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">func1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C++中闭包最大的问题是引用捕获的变量可能被移除（栈中的退出作用域和堆中的delete），而在基于<strong>垃圾回收机制</strong>的语言中实现闭包就不需要考虑这种问题（ref int呢？）。</p><p>所以下面的问题被引出</p><p>Q: 被函数对象引用捕获的局部变量还会在堆栈里吗？</p><p>A: 还在堆栈里，当出了局部变量的作用域后，再调用该函数对象并访问捕获的变量将出现未定义的行为（访问已释放或被覆盖的内存）</p><p>Q: 基于<strong>垃圾回收机制</strong>的语言中如何处理（如C#的ref int）？</p><p>A: 在编译时阻止可能访问到不在堆栈中的值的行为（如下图所示）</p><p><img src="`+r+'" alt=""></p><h3 id="lua中的闭包" tabindex="-1"><a class="header-anchor" href="#lua中的闭包"><span>Lua中的闭包</span></a></h3>',9),F={href:"https://poga.github.io/lua53-notes/function_closure.html",target:"_blank",rel:"noopener noreferrer"},O={href:"https://www.jucs.org/jucs_11_7/the_implementation_of_lua/jucs_11_7_1159_1176_defigueiredo.html",target:"_blank",rel:"noopener noreferrer"},I=t(`<div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    b <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span>
        x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        f <span class="token operator">=</span> <span class="token function">load</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment">-- 动态载入代码</span>
        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span>
    x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> b
<span class="token keyword">end</span>

c <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">c</span><span class="token punctuation">(</span><span class="token string">&#39;print(y)&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 输出6 \\n 10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码尝试在闭包函数 <code>function (str)</code> 中访问 <code>x</code> 和 <code>y</code> 时，实际上是在访问作为上值的 <code>test()</code> 栈中的 <code>x</code> 和 <code>y</code>。<code>test()</code> 相当于已被“实例化”，其分配的空间也需在不被引用时被垃圾回收。</p><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射"><span>反射</span></a></h2><blockquote><p>“反射式编程（英语：reflective programming）或反射（英语：reflection），是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。”</p></blockquote><p>目前了解到的有两种风格的反射，C#那种（Java、U++有类似实现）和Lua那种：</p>`,5),P=n("code",null,"attribute",-1),j=n("li",null,"Lua中由于没有“所有都是类”这一设定，它的反射主要用于观察虚拟机的栈或追踪程序的执行。",-1),z={href:"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84%E5%BC%8F%E7%BC%96%E7%A8%8B#C#",target:"_blank",rel:"noopener noreferrer"},D=n("code",null,"[Serialize]",-1),G=t(`<div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">// Without reflection</span>
<span class="token class-name">Foo</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">PrintHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// With reflection</span>
<span class="token class-name">Object</span> foo <span class="token operator">=</span> Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span><span class="token string">&quot;complete.classpath.and.Foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MethodInfo</span> method <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">GetType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetMethod</span><span class="token punctuation">(</span><span class="token string">&quot;PrintHello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
method<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Lua中，由于可以直接观察调用栈，所以能做的事情会比较多（分散），不再针对类型。例如：</p><ul><li>访问任意局部变量</li><li>访问上值(up value)</li><li>追踪程序执行了多少行，并在满足特定条件下执行动作</li><li>追溯某函数的运行</li><li>...</li></ul>`,3),R={href:"https://www.lua.org/pil/23.html",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.lua.org/pil/",target:"_blank",rel:"noopener noreferrer"},H=t('<h2 id="c-异步编程" tabindex="-1"><a class="header-anchor" href="#c-异步编程"><span>C#异步编程</span></a></h2><p>C#提供了三种异步编程模型。</p><p>WIP</p><p>async/await 关键字</p><ul><li>async 关键字，将函数变为异步函数</li><li>await 关键字，等待异步函数执行 <ul><li>只能在异步函数中使用</li><li>在这里发生 任务调度</li><li>对象也不一定非得是异步函数，只要实现 <code>Awaiter GetAwaiter()</code> 方法就好</li></ul></li><li>注意 <ul><li>默认使用当前线程的同步上下文 <blockquote><p>可以设置 ConfigureAwait(false) ，在回调时不检查同步上下文</p></blockquote></li></ul></li></ul><h2 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化"><span>模块化</span></a></h2><p>C#：程序集（Assembly）</p><p>C++：C++20的import</p><h2 id="appdomain" tabindex="-1"><a class="header-anchor" href="#appdomain"><span>*AppDomain</span></a></h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>',10),N={href:"https://github.com/Cpp-Club/Cxx_HOPL4_zh/blob/main/09.md",target:"_blank",rel:"noopener noreferrer"},S=n("ul",null,[n("li",null,"3.2 协程")],-1),U={href:"https://zhuanlan.zhihu.com/p/330606651",target:"_blank",rel:"noopener noreferrer"},V={href:"https://book.douban.com/subject/26285940",target:"_blank",rel:"noopener noreferrer"},W=n("ul",null,[n("li",null,"28.3 编译器如何将异步函数转换成状态机")],-1),J={href:"https://en.wikipedia.org/wiki/Closure_(computer_programming)",target:"_blank",rel:"noopener noreferrer"},M={href:"https://poga.github.io/lua53-notes/function_closure.html",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://www.jucs.org/jucs_11_7/the_implementation_of_lua/jucs_11_7_1159_1176_defigueiredo.html",target:"_blank",rel:"noopener noreferrer"},X={href:"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84%E5%BC%8F%E7%BC%96%E7%A8%8B#",target:"_blank",rel:"noopener noreferrer"},K={href:"https://learn.microsoft.com/zh-cn/dotnet/fundamentals/reflection/reflection",target:"_blank",rel:"noopener noreferrer"},Y={href:"https://www.lua.org/pil/",target:"_blank",rel:"noopener noreferrer"};function Z($,nn){const e=l("ExternalLinkIcon"),o=l("RouteLink");return i(),u("div",null,[k,h,m,n("blockquote",null,[n("p",null,[s('"协程提供了一种协作式多任务模型，比使用线程或进程要高效得多。" '),_,s(' "C++20 协程的历史始于 Niklas Gustafsson（微软）关于“可恢复函数”的提案 [Gustafsson 2012]。" '),b,s(),n("div",v,[s(" —— "),n("a",f,[s("C++20：方向之争 - Cxx_HOPL4, Github"),a(e)])])])]),g,C,w,x,n("ul",null,[n("li",null,[s("无栈协程：C#中的 "),y,s(" 设计可以看作一种无栈协程（但一般没人这么叫），该类设计被称为一种“编译器魔法”。这类设计将函数转化为状态机，局部变量变为状态机对象的字段。通过状态机的状态来满足“可恢复”这一特性。（可以参考"),n("a",E,[s("《CLR via C# 第四版》"),a(e)]),s("的第28.3节）")]),L]),A,n("blockquote",null,[n("p",null,[s("可以在在线的cpp->汇编网站上查看结果 "),n("a",B,[s("cpp separate complilation - hackingcpp"),a(e)])])]),q,n("p",null,[s("lua中的函数就是闭包（“函数是一类特殊的闭包”），相比C++的函数对象，lua语言由于一开始便支持闭包，则提供了“更好的”实现方法。其实现利用了上值等概念，可以参考一些代码解析，如: "),n("a",F,[s("Functions & Closures Implement - poga, github page"),a(e)]),s("，"),n("a",O,[s("The Implementation of Lua 5.0 - Roberto Ierusalimschy"),a(e)]),s("。下面一段代码可以帮助理解lua中的闭包和C++中函数对象的不同。")]),I,n("ul",null,[n("li",null,[s("C#的反射是对类观察（获取构造器、成员和 "),P,s(" ）修改和实例化、对函数观察（获取参数列表）和调用，是通过读取"),a(o,{to:"/Language/CompileCsharp.html#metadata"},{default:p(()=>[s("metadata")]),_:1}),s("实现的。")]),j]),n("p",null,[s("下方是一个来自"),n("a",z,[s("wiki"),a(e)]),s("的C#的例子。例子中，使用反射实例化了特定名称的类和方法。")]),n("blockquote",null,[n("p",null,[s("C#给类或方法“打上”特性(如"),D,s(")，再通过反射读取可以做很多有趣的事。例如在Unity中给所有测试方法映射一个按钮，参考"),a(o,{to:"/UnityComponent/CustomEditor.html#%E4%BE%8B%E5%AD%90-%E7%94%A8%E5%8F%8D%E5%B0%84-reflect-%E5%92%8C%E7%89%B9%E6%80%A7-attribute-%E6%9D%A5%E6%B5%8B%E8%AF%95"},{default:p(()=>[s("自定义Editor#利用反射测试")]),_:1})])]),G,n("p",null,[s("在"),n("a",R,[s("《Programming in Lua》 第23章，调试库"),a(e)]),s(" 中描述了一些，对应"),n("a",T,[s("第四版书（Lua5.3）"),a(e)]),s("的内容则是第25章（反射）")]),H,n("ul",null,[n("li",null,[n("a",N,[s("C++20：方向之争 - Cxx_HOPL4, Github"),a(e)]),S]),n("li",null,[n("a",U,[s("有栈协程与无栈协程 - 李明亮等100万人，知乎"),a(e)])]),n("li",null,[n("a",V,[s("《CLR via C# 第四版》"),a(e)]),W]),n("li",null,[n("a",J,[s("Closure (computer programming) - Wikipedia"),a(e)])]),n("li",null,[s("Lua闭包实现 "),n("ul",null,[n("li",null,[n("a",M,[s("Functions & Closures Implement - poga, github page"),a(e)])]),n("li",null,[n("a",Q,[s("The Implementation of Lua 5.0 - Roberto Ierusalimschy"),a(e)])])])]),n("li",null,[s("反射 "),n("ul",null,[n("li",null,[n("a",X,[s("反射式编程 - wikepedia"),a(e)])]),n("li",null,[n("a",K,[s(".NET 中的反射 - learn.microsoft"),a(e)])]),n("li",null,[n("a",Y,[s("Lua程序设计 第四版 - Roberto"),a(e)]),s("第25章")])])])])])}const en=c(d,[["render",Z],["__file","OtherFeatures.html.vue"]]),tn=JSON.parse('{"path":"/Language/OtherFeatures.html","title":"其他特性","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"协程","slug":"协程","link":"#协程","children":[]},{"level":2,"title":"闭包","slug":"闭包","link":"#闭包","children":[{"level":3,"title":"C++的闭包","slug":"c-的闭包","link":"#c-的闭包","children":[]},{"level":3,"title":"Lua中的闭包","slug":"lua中的闭包","link":"#lua中的闭包","children":[]}]},{"level":2,"title":"反射","slug":"反射","link":"#反射","children":[]},{"level":2,"title":"C#异步编程","slug":"c-异步编程","link":"#c-异步编程","children":[]},{"level":2,"title":"模块化","slug":"模块化","link":"#模块化","children":[]},{"level":2,"title":"*AppDomain","slug":"appdomain","link":"#appdomain","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1713700197000,"updatedTime":1740906148000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":8}]},"readingTime":{"minutes":7.85,"words":2354},"filePathRelative":"Language/OtherFeatures.md","localizedDate":"April 21, 2024"}');export{en as comp,tn as data};
