import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,o as r,c as s,a as e,b as l,d as n,e as o}from"./app-BX3Xhc_b.js";const u="/assets/hotfix-0-DII1PqQD.png",c={},h=o('<h1 id="热更新方案" tabindex="-1"><a class="header-anchor" href="#热更新方案"><span>热更新方案</span></a></h1><img src="'+u+'"><p>热更新是游戏开发中一种技术，允许在不影响游戏运行的情况下更新内容，修复错误或添加新功能，通常通过下载补丁或更新程序来实现，提供了灵活性和快速响应性。</p><p>热更新可以拆分为以下两个概念：</p><ul><li>资源热更新：更新游戏中的资源文件，如模型、音频、纹理、关卡配置和技能数据表配置等。</li><li>代码热更新：更新游戏中的代码逻辑，例如修复bug、改进性能或添加新功能，而无需重新打包发布应用程序。</li></ul><p>本文主要讨论<strong>代码热更新</strong>，将从理论角度分析热更新方案的优劣，并以<strong>XLua</strong>为例，介绍几个常用场景。</p><blockquote><p>感觉<strong>资源热更新</strong>的难点主要在打包、解包和包的管理上面，可以参考<a href="../UnityComponent/Resource">资源管理页面</a>。</p></blockquote><h2 id="外部代码和交互" tabindex="-1"><a class="header-anchor" href="#外部代码和交互"><span>外部代码和交互</span></a></h2><p>热更新技术一般会引入外部代码（通常是lua或ts写的），因为引擎使用的脚本语言很难动态加载：</p><ul><li>Unity中的C#由于IL2cpp优化技术和IOS平台的奇怪政策，基于C#的热更新不太好做（2023年起，HybridCLR可能会产生一些不同）。</li><li>UE的U++是怎么个事呢，暂时不知道捏</li></ul><p>那么在unity中，需要考虑C#和<strong>外部代码的交互</strong>。原理方面可以看看C#的平台调用方式 <code>P/Invoke</code> (Platform Invoke, 平台调用)，而实现细节方面可以看看一些分析文章，或直接硬啃热特定更技术的代码（如XLua）。交互过程可以分为以下两个部分：</p>',11),d=e("li",null,[l("C#的 "),e("code",null,"P/Invoke"),l(" 情况下：C#调用外部代码（extern和DllImport），外部代码回调C#（委托和传入调用）")],-1),p={href:"https://www.cnblogs.com/msxh/p/9813147.html",target:"_blank",rel:"noopener noreferrer"},_=e("li",null,[l("参数传递（写入和读取） "),e("ul",null,[e("li",null,"sturct和class的优化？结合具体的方案来看，更多的还是看源码吧。")])],-1),f={href:"https://zhuanlan.zhihu.com/p/40406096",target:"_blank",rel:"noopener noreferrer"},m=e("br",null,null,-1),g=e("code",null,"P/Invoke",-1),b=e("code",null,"IL2Cpp",-1),x=e("strong",null,"可能",-1),L=e("code",null,"P/Invoke",-1),k=e("code",null,"IL2Cpp",-1),I=e("code",null,"P/Invoke",-1),C=e("h2",{id:"热更新方案-1",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#热更新方案-1"},[e("span",null,"热更新方案")])],-1),y={href:"https://github.com/Tencent/xLua",target:"_blank",rel:"noopener noreferrer"},v=e("ul",null,[e("li",null,"特性：使用lua（lua在游戏热更新界有一定历史，unity和ue都有lua的热更方案）"),e("li",null,"为什么不选：使用lua写逻辑和c#相差很大")],-1),T=e("li",null,[l("ILRuntime "),e("ul",null,[e("li",null,"特性：基于Mono，使用C#"),e("li",null,"为什么不选：ios不支持Mono JIT，Interpreter又太慢")])],-1),A={href:"https://github.com/focus-creative-games/hybridclr",target:"_blank",rel:"noopener noreferrer"},U=e("ul",null,[e("li",null,"特性：拓展自IL2cpp，使用C#"),e("li",null,"为什么不选：2021年出现？比较新，而且商业化")],-1),q={href:"https://github.com/Tencent/puerts",target:"_blank",rel:"noopener noreferrer"},S=e("ul",null,[e("li",null,"特性：支持Unity和UE，使用TypeScript"),e("li",null,"为什么不选：使用TypeScript写逻辑和c#相差很大，但TypeScript是静态语言，比lua好")],-1),B=o('<p>看知乎上的一些讨论，感觉<code>HybridCLR</code>倾向于热更新逻辑和框架逻辑在同一个作用域，而其他方案则分离热更新逻辑和框架逻辑。</p><div class="hint-container tip"><p class="hint-container-title">相关概念</p><ul><li>AOT(Ahead-of-time, 提前编译) <ul><li>区别于&quot;完全静态编译（Full-ahead-of-time,Full-AOT）:程序运行前，将所有源码编译成目标平台的原生码。&quot; // 感觉怪怪的</li><li>Unity文档是这样描述的：&quot;Ahead of Time (AOT) compilation is an optimization method used by all platforms except iOS for optimizing the size of the built player.&quot;</li><li>程序运行之前，将.exe或.dll文件中的CIL的byte code部分转译为目标平台的原生码并且存储，程序运行中仍有部分CIL的byte code需要JIT编译。</li></ul></li><li>JIT(Just-in-time, 即时编译) <ul><li>程序运行过程中，将CIL的byte code转译为目标平台的原生码。</li><li>具体在C#中，执行函数前会加载函数需要的程序集，并在执行方法时编译方法的IL代码，一个方法反复执行在同一个AppDomain中时，只用编译一遍。</li></ul></li><li>Interpreter(解释器) <ul><li>参考Python等解释语言，由于每一段逻辑都要运行时编译，会显著影响效率。</li></ul></li></ul></div><h2 id="热更新流程-xlua" tabindex="-1"><a class="header-anchor" href="#热更新流程-xlua"><span>热更新流程-XLua</span></a></h2>',3),X={href:"https://blog.csdn.net/qq_28299311/article/details/104870024",target:"_blank",rel:"noopener noreferrer"},H=o("<ul><li>明确需要热更新的位置（通过<code>[Hotfix]</code>特性），并生成配置信息<code>XLua -&gt; Generate Code</code><ul><li>在高版本unity中，<code>[Hotfix]</code>特性的使用方式与文章中不同，详见github上的文档。</li></ul></li><li>编写替换逻辑的lua脚本，xlua提供的api有<code>xlua.hotfix(class, [method_name], fix)</code>和<code>util.hotfix_ex(class, method_name, fix)</code></li><li>打包热更新的lua文本资源(TextAsset)为AssetBundle，并通过某种方式获取（如模拟下载）</li><li>配置载入打包(AssetBundle)的逻辑，并执行其中的lua代码</li><li>确保xlua其他配置正确(如HOTFIX_ENABLE宏的配置，和Editor下启用<code>XLua-&gt;Hotfix Inject In Editor</code>)，然后运行测试结果是否符合预期。</li></ul>",1),P={href:"https://github.com/Tencent/xLua/blob/master/Assets/XLua/Doc/hotfix.md",target:"_blank",rel:"noopener noreferrer"},E=e("p",null,[e("strong",null,"通过了解上述过程得知需要学习以下知识：")],-1),O=e("ul",null,[e("li",null,"XLua的热更新使用方法"),e("li",null,[l("AssetBundle能够存储的内容 "),e("blockquote",null,[e("p",null,"AssetBundle 是一个存档文件，包含可在运行时由 Unity 加载的特定于平台的非代码资源（比如模型、纹理、预制件、音频剪辑甚至整个场景）")])]),e("li",null,"*AssetBundle的管理")],-1),z=e("h3",{id:"常见的热更新场景",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#常见的热更新场景"},[e("span",null,"常见的热更新场景")])],-1),D=e("li",null,"需要为已有的逻辑打补丁（参考上文的例子）",-1),w={href:"https://github.com/Tencent/xLua/tree/master/Assets/XLua/Examples/02_U3DScripting",target:"_blank",rel:"noopener noreferrer"},N=e("h2",{id:"参考",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考"},[e("span",null,"参考")])],-1),R={href:"https://infiniteflight.com/timeline/20-1-hotfix-update",target:"_blank",rel:"noopener noreferrer"},J={href:"https://learn.microsoft.com/zh-cn/dotnet/standard/native-interop/pinvoke",target:"_blank",rel:"noopener noreferrer"},M={href:"https://zhuanlan.zhihu.com/p/663371215",target:"_blank",rel:"noopener noreferrer"},V={href:"https://blog.csdn.net/qq_28299311/article/details/104870024",target:"_blank",rel:"noopener noreferrer"};function F(j,G){const t=a("ExternalLinkIcon");return r(),s("div",null,[h,e("ul",null,[e("li",null,[l("通过ABI（或别的什么）签名调用指定的函数 "),e("ul",null,[d,e("li",null,[l("热更新情况的优化，反射和反射表，又或是更复杂的策略，如ToLua的warp(参考"),e("a",p,[l("【Unity游戏开发】tolua之wrap文件的原理与使用 - 马三小伙儿，cnblog"),n(t)]),l(")")])])]),_]),e("blockquote",null,[e("p",null,[l("在简单的虚拟机情况下，这个情况会简单不少，因为一句虚拟机代码通常会对应一个宿主代码函数（如C++和Lua的情况，参考"),e("a",f,[l("C++/Lua交互指南 - Ocean藏心，知乎"),n(t)]),l("）。"),m,l("但在游戏引擎中就大大增加了复杂度。在unity的xlua方案情况下，脚本语言为C#，C#通过 "),g,l(" 调用C++编译的Lua虚拟机代码库，而且由于 "),b,l(" 、代码剪裁等优化，最终"),x,l('会是"C++版的 '),L,l(' " 调用C++编译的Lua虚拟机代码库。（这方面我也不是很了解，很好奇 '),k,l(" 后的 "),I,l(" 是什么玩意，以后有空再来探索吧 TODO）")])]),C,e("ul",null,[e("li",null,[e("a",y,[l("xlua"),n(t)]),v]),T,e("li",null,[e("a",A,[l("HybridCLR(曾用名：huatuo)"),n(t)]),U]),e("li",null,[e("a",q,[l("puerTS"),n(t)]),S])]),B,e("p",null,[l("有一篇文章简单介绍了热更新的流程，目的是替换一段编译好的C#脚本："),e("a",X,[l("Unity - AssetBundle和XLua热更新教程（简单详细） - 长生但酒狂 csdn"),n(t)]),l("。其过程可以描述为：")]),H,e("blockquote",null,[e("p",null,[l("XLua的使用方面，请参考"),e("a",P,[l("热补丁操作指南"),n(t)]),l("和其他文档获取更详细的内容。")])]),E,O,z,e("ol",null,[D,e("li",null,[l("需要添加新的逻辑（Monobehaviour） "),e("ul",null,[e("li",null,[l("可以参考"),e("a",w,[l("02_U3DScripting: 展示怎么用lua来写MonoBehaviour"),n(t)]),l("的例子，通过预定义的支持lua的C#脚本，在热更新时只需在prefab中引用它并传入新逻辑的lua脚本即可。")])])])]),N,e("ul",null,[e("li",null,[l("头图："),e("a",R,[l("20.1 Hotfix Update - infiniteflight"),n(t)])]),e("li",null,[e("a",J,[l("平台调用 (P/Invoke) - learn.microsoft.com"),n(t)])]),e("li",null,[e("a",M,[l("Unity 中的Mono与IL2CPP - 知乎"),n(t)])]),e("li",null,[e("a",V,[l("Unity - AssetBundle和XLua热更新教程（简单详细） - 长生但酒狂 csdn"),n(t)])])])])}const W=i(c,[["render",F],["__file","HotfixSchema.html.vue"]]),Y=JSON.parse('{"path":"/Language/HotfixSchema.html","title":"热更新方案","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"外部代码和交互","slug":"外部代码和交互","link":"#外部代码和交互","children":[]},{"level":2,"title":"热更新方案","slug":"热更新方案-1","link":"#热更新方案-1","children":[]},{"level":2,"title":"热更新流程-XLua","slug":"热更新流程-xlua","link":"#热更新流程-xlua","children":[{"level":3,"title":"常见的热更新场景","slug":"常见的热更新场景","link":"#常见的热更新场景","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1713700197000,"updatedTime":1714495293000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":3}]},"readingTime":{"minutes":5.7,"words":1710},"filePathRelative":"Language/HotfixSchema.md","localizedDate":"April 21, 2024"}');export{W as comp,Y as data};
