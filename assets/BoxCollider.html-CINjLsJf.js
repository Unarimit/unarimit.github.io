import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,o as l,c as i,a as e,b as s,d as r,e as d}from"./app-BX3Xhc_b.js";const t={},c=d(`<h1 id="碰撞箱" tabindex="-1"><a class="header-anchor" href="#碰撞箱"><span>碰撞箱</span></a></h1><p>碰撞箱不仅仅可以解决<strong>物理</strong>碰撞问题（从两球相撞到赛车游戏），还可以解决RPG中的互动问题（逻辑碰撞）。</p><p>两个同时拥有<code>collider</code>组件的Game Object需要至少其中一个拥有<code>rigid body</code>才能发生碰撞事件。</p><h2 id="collider" tabindex="-1"><a class="header-anchor" href="#collider"><span>Collider</span></a></h2><p>Collider（碰撞器）组件是Unity中用于处理碰撞检测和触发器事件的组件之一。它定义了游戏对象的物理形状，可以与其他游戏对象进行交互。下面是Collider组件的一些常用属性和它们的作用：</p><p>关键属性：</p><ul><li><code>IsTrigger</code>（是触发器）：<code>IsTrigger</code>属性确定碰撞器是否为触发器。如果启用了该属性，碰撞器将不会产生物理碰撞响应，而是触发触发器事件（例如<code>OnTriggerEnter</code>、<code>OnTriggerStay</code>和<code>OnTriggerExit</code>）。</li><li><code>LayerOverride</code>：控制他影响的层，如战斗技能的碰撞器可以只工作在角色层，减少不必要的碰撞计算开销 <ul><li>关于collider和rigid body对Layer override的覆盖，rigidbody的优先级高于collider的</li></ul></li></ul><p>拥有碰撞器的Game Object可以触发碰撞事件，需要自行监听并实现相应功能</p><ul><li><code>OnCollisionEnter</code>、<code>OnCollisionStay</code>和<code>OnCollisionExit</code></li></ul><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">// 一段被碰撞后造成1点伤害的代码</span>
<span class="token keyword">private</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnCollisionEnter</span><span class="token punctuation">(</span><span class="token class-name">Collision</span> collision<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    CombatContextManager<span class="token punctuation">.</span>Instance<span class="token punctuation">.</span><span class="token function">DellDamage</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> transform<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="mesh-collider和其他collider" tabindex="-1"><a class="header-anchor" href="#mesh-collider和其他collider"><span>Mesh Collider和其他Collider</span></a></h3><p>Mesh Collider可以完美的贴合模型的碰撞面，但其性能开销是非常大的。</p><p>官方建立使用大模型作为MeshCollider时，可以先拆成小模型，在各自做MeshCollider。</p><p>实际开发中，可以使用<code>BoxCollider</code>, <code>SphereCollider</code>, <code>CapsuleCollider</code>做碰撞体的简化。如人形角色的碰撞体，大部分情况可以使用<code>CapsuleCollider</code>作为平替。</p><h2 id="rigid-body" tabindex="-1"><a class="header-anchor" href="#rigid-body"><span>rigid body</span></a></h2><p>Rigidbody组件是Unity中用于模拟物体物理行为的组件之一。它可以赋予游戏对象真实的物理特性，包括重力、碰撞和惯性。</p><details class="hint-container details"><summary>gpt介绍主要属性及其用法</summary><ol><li><p>Mass（质量）：Mass属性定义了游戏对象的质量，影响它对外力的响应和物理模拟的效果。较大的质量值意味着对象更难受到外力的移动或改变方向。</p></li><li><p>Drag（阻力）：Drag属性模拟了游戏对象在运动中遇到的空气或液体阻力。较高的阻力值会减缓游戏对象的速度，使其更快地停下来。</p></li><li><p>Angular Drag（角阻力）：Angular Drag属性定义了游戏对象在旋转时所受到的阻力。增加角阻力会导致游戏对象更快地停止旋转。</p></li><li><p>Use Gravity（使用重力）：Use Gravity属性确定游戏对象是否受到重力的影响。启用此属性后，游戏对象会受到场景中的重力影响，否则它将不受重力影响而漂浮。</p></li><li><p>Is Kinematic（是运动学物体）：Is Kinematic属性指示物体是否为运动学物体。如果启用了该属性，物体将不受物理引擎的影响，你可以通过代码直接控制物体的位置和旋转。</p></li><li><p>Constraints（约束）：Constraints属性控制游戏对象在物理模拟中的约束情况。你可以限制对象的位置和旋转在某些轴上的运动，或者保持物体在某些轴上保持静止。</p></li></ol></details><details class="hint-container details"><summary>一次\`AddForce\`引发的问题</summary><p>我有一个需求是“在0.2秒把物体向前推进20m”，那我的force应该是<code>var force = transform.forward * 20 / 0.2f</code>，或者是这个数的10倍，100倍等，然而实际上我需要使用<code>var force = transform.forward * 1000 / 0.2f</code>才能达到我想要的效果。</p><p>这和AddForce的默认模式<code>ForceMode.Force</code>：<code>Add a continuous force to the rigidbody, using its mass.</code>中的<code>continuous</code>有关，我的物理处理帧刚好是一秒50帧。</p><p>解决方案：通过<code>GetComponent&lt;Rigidbody&gt;().velocity = transform.forward * 20 / 0.2f;</code>解决，或使用<code>ForceMode.VelocityChange</code></p></details><h2 id="实现原理和使用须知" tabindex="-1"><a class="header-anchor" href="#实现原理和使用须知"><span>实现原理和使用须知</span></a></h2><p>Unity作为一个成熟的游戏引擎，配置正确的Layer可以使碰撞运算的性能达到state of art，除非有一些特殊的需求（例如多线程模拟人物骨骼，或一个简化的检测系统等），一般都可以用碰撞箱做范围检测。</p><p>例如：</p><ul><li>在射击游戏内检测子弹是否命中敌人（如果出于一些原因勾选<code>IsTrigger</code>导致rigidbody的<code>ContinueDetection</code>不能生效，可能需要自行处理运动过快导致的碰撞未触发问题）</li><li>在塔防游戏内检测敌人是否在攻击范围</li><li>在rpg中检测可交互物体是否在交互范围</li><li>等等</li></ul><p>需要注意的是，尽量使用Unity提供的基础碰撞体（Box，Sphere，Capsule等），避免MeshCollider的使用。</p><p>关于其原理，检测部分应该涉及空间分割算法和包围盒等优化；物体计算方面比较复杂，一般使用外部的物理模拟库实现。</p><blockquote><p>补充更多内容和参考文章，如服务端计算、空间算法等 WIP</p></blockquote><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,26),p={href:"https://www.youtube.com/watch?v=bh9ArKrPY8w",target:"_blank",rel:"noopener noreferrer"};function u(h,m){const o=a("ExternalLinkIcon");return l(),i("div",null,[c,e("p",null,[e("a",p,[s("Colliders - Unity Official Tutorials - Youtube"),r(o)])])])}const y=n(t,[["render",u],["__file","BoxCollider.html.vue"]]),C=JSON.parse('{"path":"/UnityComponent/BoxCollider.html","title":"碰撞箱","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Collider","slug":"collider","link":"#collider","children":[{"level":3,"title":"Mesh Collider和其他Collider","slug":"mesh-collider和其他collider","link":"#mesh-collider和其他collider","children":[]}]},{"level":2,"title":"rigid body","slug":"rigid-body","link":"#rigid-body","children":[]},{"level":2,"title":"实现原理和使用须知","slug":"实现原理和使用须知","link":"#实现原理和使用须知","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1707819000000,"updatedTime":1707999118000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":2}]},"readingTime":{"minutes":4.21,"words":1262},"filePathRelative":"UnityComponent/BoxCollider.md","localizedDate":"February 13, 2024"}');export{y as comp,C as data};
