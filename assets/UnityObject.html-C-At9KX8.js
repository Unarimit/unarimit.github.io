import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as i,c as d,d as s,w as c,a as e,b as n,e as l}from"./app-BX3Xhc_b.js";const r="/assets/unity-null-1-DcL820A9.png",u="/assets/unity-null-2-CO5u0YyT.png",m={},k=l(`<h1 id="unityobject" tabindex="-1"><a class="header-anchor" href="#unityobject"><span>UnityObject</span></a></h1><p>指的是<code>UnityEngine.Object</code>, <code>MonoBehaviour</code>和<code>GameObject</code>都派生自这个类。</p><p>通过这个类可以看出一些Unity对脚本生命周期的管理。</p><blockquote><p>如<code>Instantiate</code>方法和<code>Destroy</code>方法</p></blockquote><h2 id="判断unityobject是否被destroy" tabindex="-1"><a class="header-anchor" href="#判断unityobject是否被destroy"><span>判断UnityObject是否被Destroy</span></a></h2><p>以下简称为“判空”，这里的“判空”是指判断<code>UnityEngine.Object</code>是否执行了<code>Destroy</code>方法，而不是判断它有没有指向托管堆的一块内存（空引用）。</p><p>“判空”最好使用<code>x.Equals(null)</code>方法。也可以使用<code>x == null</code>方法，但要确保<code>x</code>的类型确实是一个<code>UnityEngine.Object</code>或其派生类的类型。如果<code>x</code>是一个接口类型（<code>IFoo x</code>, <code>interface IFoo{ }</code>），那么<code>x == null</code>执行的是<code>System.Object</code>类的引用判空方法:<code>System.Object.ReferenceEquals()</code>，不能判断被<code>Destroy</code>的物体是否为“空”。</p><blockquote><p>unity的<code>Destroy</code>不会真的释放被引用对象的内存空间，C#本身也做不到(?)。<code>UnityEngine.Object</code>重写<code>Equals</code>方法实现了对<code>Destroy</code>方法“判空”的支持，也重载了<code>operator ==</code>方法。但不像<code>System.Object</code>类的<code>Equals</code>方法，他是<code>virtual</code>的，而重载运算符只能以静态方法的方式实现（属于<code>equals</code>和<code>==</code>的讨论范围了。<code>equals</code>也有一个特点，它作为成员方法，对象为空的时候会报空引用异常，所以有时候可能需要两者一起使用）。</p></blockquote><p>还要注意<code>Destroy</code>是下一帧生效的问题。</p><p>下面是一段调试时的代码，使用<code>(x被定义为一个接口类型)x == null</code>判断被<code>Destroy</code>的物体时产生的问题。</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">// 定义</span>
<span class="token keyword">public</span> Stack<span class="token operator">&lt;</span>IOverlayUI<span class="token operator">&gt;</span> OverlayStack
<span class="token keyword">internal</span> <span class="token keyword">interface</span> <span class="token class-name">IOverlayUI</span> <span class="token comment">// 这个接口用于UI Monobehaviour实现退出方法</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="`+r+'">',12),b=e("p",null,[n("这里的"),e("code",null,"this"),n("指的是"),e("code",null,"OnEscMenu"),n("中的局部变量"),e("code",null,"t"),n("。")],-1),y=e("img",{src:u},null,-1),h=e("p",null,"它进去了。。。",-1),v=l(`<p>根据上述讨论验证一下：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token class-name"><span class="token keyword">var</span></span> mb <span class="token operator">=</span> <span class="token punctuation">(</span>MonoBehaviour<span class="token punctuation">)</span>t<span class="token punctuation">;</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output &quot;null&quot;</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>mb <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output true</span>
Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,3),_={href:"https://gamedev.stackexchange.com/questions/128971/interface-object-never-equals-null",target:"_blank",rel:"noopener noreferrer"},g={href:"https://docs.unity3d.com/cn/current/Manual/class-Object.html",target:"_blank",rel:"noopener noreferrer"},f={href:"https://docs.unity3d.com/cn/current/ScriptReference/Object.html",target:"_blank",rel:"noopener noreferrer"};function j(O,x){const a=o("center"),t=o("ExternalLinkIcon");return i(),d("div",null,[k,s(a,null,{default:c(()=>[b]),_:1}),y,s(a,null,{default:c(()=>[h]),_:1}),v,e("ul",null,[e("li",null,[e("a",_,[n("Interface Object Never Equals Null - StackExchange"),s(t)])]),e("li",null,[e("a",g,[n("重要的类 Object - Unity Doc"),s(t)])]),e("li",null,[e("a",f,[n("Object API - Unity Doc"),s(t)])])])])}const D=p(m,[["render",j],["__file","UnityObject.html.vue"]]),E=JSON.parse('{"path":"/UnityComponent/UnityObject.html","title":"UnityObject","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"判断UnityObject是否被Destroy","slug":"判断unityobject是否被destroy","link":"#判断unityobject是否被destroy","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1707819000000,"updatedTime":1707819000000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":1}]},"readingTime":{"minutes":1.66,"words":497},"filePathRelative":"UnityComponent/UnityObject.md","localizedDate":"February 13, 2024"}');export{D as comp,E as data};
