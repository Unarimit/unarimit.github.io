import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as i,c as l,a as t,b as e,d as r,e as n}from"./app-BX3Xhc_b.js";const c="/assets/transformation-0-0itzWvb8.png",p="/assets/transformation-2-BiGs9y5W.png",m="/assets/transformation-3-BDWXj_ZJ.png",h="/assets/transformation-4-jjWnoonw.png",d="/assets/transformation-5-CBUaElX0.png",_="/assets/transformation-6-Bcx2wYvg.png",f="/assets/transformation-7-Ce871elm.png",g="/assets/transformation-8-Bd-lOXqV.png",u={},b=n('<h1 id="坐标变换-transformation" tabindex="-1"><a class="header-anchor" href="#坐标变换-transformation"><span>坐标变换 Transformation</span></a></h1><p>渲染管线的第一步，将物体进行坐标变换，以便下一步渲染。</p><img width="500" src="'+c+'"><blockquote><p>解释上图中的流程： <br>(1) 模型变换(modeling tranformation)：这一步的目的是将虚拟世界中或者更具体点，游戏场景中的物体调整至他们应该在的位置 <br>(2) 摄像机变换(camera tranformation)：在游戏中我们真正在乎的是摄像机(或者说眼睛)所看到的东西，也就是需要得到物体与摄像机的相对位置 <br>(3) 投影变换(projection tranformation)：在摄像机变换之后，我们得到了所有可视范围内的物体相对于摄像机的相对位置坐标(x,y,z)，之后根据具体情况选择平行投影或是透视投影，将三维空间投影至标准二维平面([-1,1]^2)之上 （tips：这里的z并没有丢掉，为了之后的遮挡关系检测） <br>(4) 视口变换(viewport transformation)：将处于标准平面映射到屏幕分辨率范围之内，即[-1,1]^2-&gt; [0,width]*[0,height], 其中width和height指屏幕分辨率大小</p></blockquote><p>工作大致可以分为两步：</p><ul><li>坐标变换（模型视图变换）：将物体从世界坐标系变换到相机坐标系。</li><li>投影：将物体根据投影模式投影到正确的屏幕位置上。</li></ul><p>都是做矩阵运算</p><h2 id="坐标变换" tabindex="-1"><a class="header-anchor" href="#坐标变换"><span>坐标变换</span></a></h2><p>坐标变换依赖于仿射变换，通过定义<code>ModelView</code>变换矩阵，使每个物体都乘上这个矩阵。</p><details class="hint-container details"><summary>一些仿射变换知识</summary><p>使用4*4矩阵表示仿射变换（线性变化+平移）</p><img width="400" src="'+p+'"><p>缩放和平移</p><img width="400" src="'+m+'"><p>旋转</p><img width="400" src="'+h+'"><img width="600" src="'+d+'"><p>利用矩阵的性质: 由于矩阵的乘法满足结合律，可以预计算变换矩阵，提高计算效率。</p></details><img width="600" src="'+_+'">',11),w=t("code",null,"ModelView",-1),k={href:"https://www.bilibili.com/video/BV1X7411F744/?p=4",target:"_blank",rel:"noopener noreferrer"},v=n('<h2 id="投影" tabindex="-1"><a class="header-anchor" href="#投影"><span>投影</span></a></h2><p>有两种常用的投影：正交投影和透视投影，透视投影比较符合我们人眼观察世界的方式。</p><p>图：透视投影(左)和正交投影(右)</p><img width="600" src="'+f+'"><p>由于透视投影遵从近大远小，其变换矩阵会更复杂一些。</p><img width="600" src="'+g+'"><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>',7),x={href:"https://www.bilibili.com/video/BV1X7411F744/?p=4",target:"_blank",rel:"noopener noreferrer"},B={href:"https://zhuanlan.zhihu.com/p/144329075",target:"_blank",rel:"noopener noreferrer"};function T(V,z){const a=s("ExternalLinkIcon");return i(),l("div",null,[b,t("p",null,[w,e("变换矩阵的求解方法可以具体看"),t("a",k,[e("GAMES101视频"),r(a)]),e("，视频中给出了一种反向推导的方法。")]),v,t("ul",null,[t("li",null,[t("a",x,[e("GAMES101-闫令琪-Transformation Bilibili"),r(a)])]),t("li",null,[t("a",B,[e("计算机图形学二：视图变换(坐标系转化，正交投影，透视投影，视口变换) 孙小磊 - 知乎"),r(a)])])])])}const y=o(u,[["render",T],["__file","Transformation.html.vue"]]),C=JSON.parse('{"path":"/ComputerGraphics/Transformation.html","title":"坐标变换 Transformation","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"坐标变换","slug":"坐标变换","link":"#坐标变换","children":[]},{"level":2,"title":"投影","slug":"投影","link":"#投影","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1708341076000,"updatedTime":1708341076000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":1}]},"readingTime":{"minutes":2.23,"words":670},"filePathRelative":"ComputerGraphics/Transformation.md","localizedDate":"February 19, 2024"}');export{y as comp,C as data};
