import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as s,c,a as e,b as a,d as n,e as i}from"./app-BX3Xhc_b.js";const r={},d=i(`<h1 id="常用规范" tabindex="-1"><a class="header-anchor" href="#常用规范"><span>常用规范</span></a></h1><h2 id="命名规范" tabindex="-1"><a class="header-anchor" href="#命名规范"><span>命名规范</span></a></h2><details class="hint-container details"><summary>GPT谈Unity命名规范</summary><p>在Unity中编写C#脚本时，通常遵循以下命名规范：</p><ol><li><p>类名：使用帕斯卡命名法（PascalCase），即每个单词的首字母大写，不使用下划线。例如：<code>PlayerController</code>。</p></li><li><p>方法名和变量名：使用驼峰命名法（camelCase），即第一个单词的首字母小写，后续单词的首字母大写，不使用下划线。例如：<code>moveSpeed</code>，<code>attackPlayer()</code>。</p></li><li><p>常量名：使用大写字母和下划线命名（UPPER_CASE），单词之间用下划线分隔。例如：<code>MAX_HEALTH</code>。</p></li><li><p>私有变量名：通常以一个下划线开头，然后按照驼峰命名法命名。例如：<code>private int _count</code>。</p></li></ol><p>如果需要通过Inspector导入的变量，可以考虑在变量名前面加上<code>SerializeField</code>属性，这样即使是私有变量也可以在Inspector中显示。例如：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">SerializeField</span></span><span class="token punctuation">]</span>
<span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> m_health<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的<code>m_</code>只是一个命名习惯，意在提醒该变量是通过Inspector导入的。你可以根据自己的喜好选择适合你的命名方式，只要保持代码风格一致和易于理解即可。 😉</p></details><p>核心在于“只要保持代码风格一致和易于理解即可”</p><ol><li>需要Inspector注入的变量 <ul><li>使用<code>m_</code>开头+帕斯卡命名法的方式，如：<code>m_MyField</code></li></ul></li><li>通过管理类初始化的私有变量 <ul><li>使用<code>_</code>开头+驼峰命名法的方式，如: <code>_context</code></li></ul></li><li>其他私有变量（如通过find找到的组件，记录的临时状态 <ul><li>使用驼峰命名法的方式，如: <code>speed</code></li></ul></li></ol><p>WIP</p><h2 id="字段与属性" tabindex="-1"><a class="header-anchor" href="#字段与属性"><span>字段与属性</span></a></h2><p>由于<code>Serializable</code>属性并不会序列化属性（属性的本质是方法），所有一些配置文件应该写作字段的形式。</p><blockquote><p>用: <code>public int foo;</code> 而不用: <code>public int foo {get; set;}</code></p></blockquote><p>一些使用OOP设计的程序类仍可以使用属性</p><h2 id="结构体替换类" tabindex="-1"><a class="header-anchor" href="#结构体替换类"><span>结构体替换类</span></a></h2><p>尽可能使用结构体替换类，这样可以减少垃圾回收。</p><p>TODO: 待核实</p><blockquote><p>没错，但结构体如果封装到类中，一样会在堆上分配内存。在代码中创建struct在CLR中会分配到线程栈中，作用域结束就会被抛弃。在《CLR via C#》中建议：结构体不应无脑使用，他的大小最好小于16B，且不需要传递来传递去。</p></blockquote><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,15),p={href:"https://zhuanlan.zhihu.com/p/558732611",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.youtube.com/watch?v=thA3zv0IoUM",target:"_blank",rel:"noopener noreferrer"};function u(m,_){const l=t("ExternalLinkIcon");return s(),c("div",null,[d,e("ul",null,[e("li",null,[e("a",p,[a("Unity小窍门100条！！！(上) - 知乎"),n(l)]),e("ul",null,[e("li",null,[a("对应视频："),e("a",h,[a("100 UNITY TIPS!!! 🔥 - Youtube"),n(l)])])])])])])}const v=o(r,[["render",u],["__file","CommonlySpec.html.vue"]]),f=JSON.parse('{"path":"/GameCodeDesign/CommonlySpec.html","title":"常用规范","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"命名规范","slug":"命名规范","link":"#命名规范","children":[]},{"level":2,"title":"字段与属性","slug":"字段与属性","link":"#字段与属性","children":[]},{"level":2,"title":"结构体替换类","slug":"结构体替换类","link":"#结构体替换类","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1707819000000,"updatedTime":1707819000000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":1}]},"readingTime":{"minutes":2.06,"words":618},"filePathRelative":"GameCodeDesign/CommonlySpec.md","localizedDate":"February 13, 2024"}');export{v as comp,f as data};
