import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as c,c as d,a as e,b as t,d as a,e as l}from"./app-BX3Xhc_b.js";const r="/assets/图解系统-32位虚拟内存布局-ss9gLdS9.jpg",i={},p=e("h1",{id:"内存管理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#内存管理"},[e("span",null,"内存管理")])],-1),h=e("p",null,[t("内存管理是编程语言中最重要的部分之一，理解内存管理的细节和良好的编程习惯可以减少程序出现"),e("strong",null,"内存泄漏"),t("的可能。")],-1),u=e("h2",{id:"操作系统的内存安排",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#操作系统的内存安排"},[e("span",null,"操作系统的内存安排")])],-1),_={href:"https://www.xiaolincoding.com/os/3_memory/malloc.html#linux-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7",target:"_blank",rel:"noopener noreferrer"},m=e("img",{src:r,width:"400"},null,-1),g=e("p",null,"其中内核空间为共享空间，占1个G。其他为用户空间，进程之间相互独立，占3个G。地址均为虚拟地址。（不然一个程序就把内存占满啦）",-1),k=e("p",null,"内存管理需要关注的，是栈和堆的部分，它们是程序运行过程中变动最频繁的两个区域。",-1),b=e("h2",{id:"c-堆和new",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#c-堆和new"},[e("span",null,"C++：堆和new")])],-1),w={href:"https://blog.csdn.net/happyjacob/article/details/104766843",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,[t("当然一般情况下在C++中都使用 "),e("code",null,"new"),t(" 操作符为对象在堆中分配内存，分配时会调用 "),e("code",null,"malloc"),t(" 函数。")],-1),v=e("p",null,[t("在销毁内存时则使用 "),e("code",null,"delete"),t(" 操作符，它同样可以被重载，一般是在里面调用 "),e("code",null,"free"),t(" 函数释放分配给对象的内存。")],-1),x={class:"hint-container tip"},E=l(`<p class="hint-container-title">检验</p><p>下方代码中，<code>new</code> 和 <code>delete</code> 分别做了什么？</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TestClass</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> t<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),B={href:"https://book.douban.com/subject/10505113/",target:"_blank",rel:"noopener noreferrer"},C=l('<p>特别的：</p><ul><li>对于数组对象，在删除时记得使用 <code>delete[]</code> 告诉编译器需要删除的对象是一个数组。</li><li>若想在已经分配的内存中直接初始化（而非通过new临时量再赋值的方式），可以使用 定位new，配合 <code>operator new</code> 分配空间（ 后面推出了 <code>allocator</code> stl类，标准化了 <code>operator new</code> 、<code>operator delete</code> 和 定位new 的作用）。 <blockquote><p><code>operator new</code> 是一种全局 <code>new</code>，区别于成员函数 <code>new</code>。作用类似 <code>malloc</code> ，在分配内存时不调用对象的构造函数。例： <code>int* arr = (int*)operator new(size * sizeof(int))</code></p></blockquote></li></ul><h3 id="stl提供的管理方式" tabindex="-1"><a class="header-anchor" href="#stl提供的管理方式"><span>stl提供的管理方式</span></a></h3><p><code>shared_ptr&lt;T&gt;</code>, <code>vector&lt;T&gt;</code>, <code>allocator&lt;T&gt;</code> 是我目前已知用于辅助管理内存的类。</p><p><code>shared_ptr&lt;T&gt;</code> 用于辅助程序员回收不被引用的堆对象。使用引用计数，为了避免循环引用，提供了 <code>weak_ptr&lt;T&gt;</code> 和 <code>unique_ptr&lt;T&gt;</code> 两种类分情况管理，把循环引用的避免交给了程序员。这些结构在一起被称为“智能指针”，由于弱引用需要查询对象是否被删除，故智能指针的引用计数由专门的控制结构体管理。</p><p><code>allocator&lt;T&gt;</code> 通常用于分配数组的空间，目的是分离内存分配和对象构造（因为使用new创建对象时，会执行new操作符为对象分配内存，接着执行对象的构造函数）。</p><p><code>vector&lt;T&gt;</code> 是stl提供的动态数组容器，管理了堆上的对象（当然还有其他各种容器如 <code>list&lt;T&gt;</code>、<code>set&lt;T&gt;</code> 等，但<code>array&lt;T,size&gt;</code>是分配在栈上的，和作为复合类型的内置数组一样）。</p><blockquote><p>如何证明这一点，除了直接看元素的虚拟地址之外，还可以分配一个 “size乘对象” 大小超过栈上限的数组，若出现栈溢出，则。。</p></blockquote><h3 id="其他管理内存的概念和特性" tabindex="-1"><a class="header-anchor" href="#其他管理内存的概念和特性"><span>其他管理内存的概念和特性</span></a></h3><p>由类型支持的特性：左值右值、RAII（Resource Acquisition ls Initialization，资源获取即初始化）将在<a href="./Class">类型</a>中讨论。</p><h2 id="c-托管堆和gc" tabindex="-1"><a class="header-anchor" href="#c-托管堆和gc"><span>C#：托管堆和GC</span></a></h2><p>WIP</p><p>还有unsafe指针和fix</p><h2 id="变量初始化顺序和位置" tabindex="-1"><a class="header-anchor" href="#变量初始化顺序和位置"><span>变量初始化顺序和位置</span></a></h2><h3 id="c-中" tabindex="-1"><a class="header-anchor" href="#c-中"><span>C++中</span></a></h3><table><thead><tr><th>变量类型</th><th>初始化顺序（时间）</th><th>初始化位置</th><th>默认初始化是值初始化吗？</th></tr></thead><tbody><tr><td>局部变量</td><td>--</td><td>栈</td><td>内置类型不是，自定义类型是</td></tr><tr><td>全局变量</td><td>按定义顺序</td><td>静态数据段</td><td>是</td></tr><tr><td>静态（成员）变量</td><td>按定义顺序</td><td>静态数据段</td><td>是</td></tr><tr><td>静态局部变量</td><td>第一次执行到时</td><td>静态数据段</td><td>是</td></tr><tr><td>普通成员变量</td><td>从子类到父类，按定义顺序</td><td>跟随实例</td><td>是</td></tr></tbody></table><blockquote><p>对于自定义类型，值初始化会调用其构造函数。内置类型的值初始化会将其值置 “0”，局部变量的内置类型的默认值是未定义的，如 <code>int a</code> ，<code>a</code> 可能会是一串随机数。</p></blockquote><blockquote><p>静态成员变量 比较特殊，他在类中出现仅相当于是声明，还必须要在全局作用域定义后才可以使用。</p></blockquote><h3 id="c-中-1" tabindex="-1"><a class="header-anchor" href="#c-中-1"><span>C#中</span></a></h3><p>WIP</p><h2 id="未包含的部分" tabindex="-1"><a class="header-anchor" href="#未包含的部分"><span>未包含的部分</span></a></h2><ol><li>因多线程影响而出现的特性</li></ol><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>',23),T={href:"https://www.xiaolincoding.com/os/3_memory/malloc.html#linux-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7",target:"_blank",rel:"noopener noreferrer"},y={href:"https://book.douban.com/subject/10505113/",target:"_blank",rel:"noopener noreferrer"},q=e("ul",null,[e("li",null,"12.2 动态数组"),e("li",null,"19.1 控制内存分配（new、delete、定位new）")],-1);function A(M,I){const n=s("ExternalLinkIcon");return c(),d("div",null,[p,h,u,e("p",null,[t("在"),e("a",_,[t("图解系统"),a(n)]),t("中，描述了32位linux系统中进程内存的安排，如下图所示：")]),m,g,k,b,e("p",null,[t("使用new创建的对象，分配的内存空间被称为“自由存储区”，因为new操作符可以被重载，内存不一定分配到堆上。在文章《"),e("a",w,[t("重载new/delete，在静态存储区、栈上分配空间 - 用户“-出发-”，CSDN"),a(n)]),t("》 中，就介绍了重载全局new运算符，变更分配内存位置的方法。")]),f,v,e("div",x,[E,e("p",null,[t("可以参考"),e("a",B,[t("《C++ Primer 第五版》"),a(n)]),t("19.1节")])]),C,e("ul",null,[e("li",null,[e("a",T,[t("图解系统，4.2 malloc 是如何分配内存的？#Linux 进程的内存分布长什么样？ - 小林coding"),a(n)])]),e("li",null,[e("a",y,[t("《C++ Primer 第五版》"),a(n)]),q])])])}const N=o(i,[["render",A],["__file","MemoryManage.html.vue"]]),P=JSON.parse('{"path":"/Language/MemoryManage.html","title":"内存管理","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"操作系统的内存安排","slug":"操作系统的内存安排","link":"#操作系统的内存安排","children":[]},{"level":2,"title":"C++：堆和new","slug":"c-堆和new","link":"#c-堆和new","children":[{"level":3,"title":"stl提供的管理方式","slug":"stl提供的管理方式","link":"#stl提供的管理方式","children":[]},{"level":3,"title":"其他管理内存的概念和特性","slug":"其他管理内存的概念和特性","link":"#其他管理内存的概念和特性","children":[]}]},{"level":2,"title":"C#：托管堆和GC","slug":"c-托管堆和gc","link":"#c-托管堆和gc","children":[]},{"level":2,"title":"变量初始化顺序和位置","slug":"变量初始化顺序和位置","link":"#变量初始化顺序和位置","children":[{"level":3,"title":"C++中","slug":"c-中","link":"#c-中","children":[]},{"level":3,"title":"C#中","slug":"c-中-1","link":"#c-中-1","children":[]}]},{"level":2,"title":"未包含的部分","slug":"未包含的部分","link":"#未包含的部分","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1711785342000,"updatedTime":1713245311000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":5}]},"readingTime":{"minutes":4.41,"words":1322},"filePathRelative":"Language/MemoryManage.md","localizedDate":"March 30, 2024"}');export{N as comp,P as data};
