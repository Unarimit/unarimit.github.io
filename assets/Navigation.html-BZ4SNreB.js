import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as p,c as i,a as n,b as a,d as e,e as c}from"./app-BX3Xhc_b.js";const l={},r=c(`<h1 id="寻路" tabindex="-1"><a class="header-anchor" href="#寻路"><span>寻路</span></a></h1><p>说到寻路，一定会想到A*算法，A*是一种很有名的路径搜索算法，作为启发式算法，有独特的构造方式。但在游戏中，为了贴合具体的场景（例如三维场景下的高度差，二维场景下的跳跃等），在图的构建方面会比较复杂。</p><h2 id="游戏中的寻路算法" tabindex="-1"><a class="header-anchor" href="#游戏中的寻路算法"><span>游戏中的寻路算法</span></a></h2><p>WIP 2D，3D</p><h2 id="unity方案-ainavigation" tabindex="-1"><a class="header-anchor" href="#unity方案-ainavigation"><span>Unity方案-AINavigation</span></a></h2><p><code>AINavigation</code>是一种基于A*和网格的unity内置寻路方案。由<code>NavMesh</code>和<code>NavMeshAgent</code>两个主要组件构成，起使用流程如下：</p><ol><li>Bake NavMesh，根据使用Navigation版本不同，操作会有差异 <ul><li>通过Mesh或碰撞箱建立<code>NavMesh</code></li><li>通过<code>NavMeshObstacle</code>添加空气墙</li><li>通过<code>NavMeshLink</code>添加跳跃等导航指引</li><li>通过<code>NavMeshModifier</code>给障碍物添加过滤属性</li><li>可以根据不同的agent属性添加不同的<code>NavMesh</code></li></ul></li><li>给人物添加<code>NavMeshAgent</code><ul><li>不要和<code>CharacterController</code>挂到一个go上</li></ul></li><li>调用<code>NavMeshAgent.Move(Vector3 offset)</code>，<code>NavMeshAgent</code>会自动导航至目标</li></ol><p><code>NavMeshAgent</code>和<code>CharacterController</code>一样，是操控具体人物的组件，依赖于NavMesh Surface等配置。他也向<code>CharacterController</code>一样，自带一些碰撞和移动策略。有以下三类属性:</p><ul><li><code>Steering</code>: 控制移动表现（模拟人物在不同的环境，如冰面，路面等）</li><li><code>Obstacle Avoidance</code>: 控制agent躲避其他agent，可以通过设置priority实现优先躲避，或设置Quality直接取消躲避。 <ul><li>这个属性抽象在他不受物理碰撞设置的影响</li></ul></li><li><code>PathFinding</code>: 一些寻路策略的应用</li></ul><p><strong>具体实现详见参考中的视频</strong></p><h3 id="不同层级的碰撞" tabindex="-1"><a class="header-anchor" href="#不同层级的碰撞"><span>不同层级的碰撞</span></a></h3><p>如果想实现空中单位和陆地单位不相互碰撞，可以通过将空中单位躲避优先级（<code>Obstacle Avoidance -&gt; priority</code>）调高，并躲避质量（<code>Obstacle Avoidance -&gt; Quality</code>）为None的方式实现。</p><ul><li>当然，还是为空中专门设计类似“地面”的结构比较好。</li></ul><h3 id="运行时更新navmesh" tabindex="-1"><a class="header-anchor" href="#运行时更新navmesh"><span>运行时更新NavMesh</span></a></h3><p><code>navMeshSurface.UpdateNavMesh(navMeshSurface.navMeshData);</code></p><h3 id="navmesh的使用方法" tabindex="-1"><a class="header-anchor" href="#navmesh的使用方法"><span>NavMesh的使用方法</span></a></h3><p>在烘焙<code>NavMesh</code>后，给角色挂载<code>NavMeshAgent</code>组件，实现代理式寻路。程序只需制定好地点和速度，<code>NavMeshAgent</code>组件就会控制角色按最短路径移动到目标地点。</p><p>下面是一段自己写的移动到目标位置的代码和使用NavMesh的代码的对比（未考虑寻路和遮挡）</p><details class="hint-container details"><summary>展开查看</summary><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token return-type class-name">IEnumerator</span> <span class="token function">MoveOnceSub</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">float</span></span> MaxSpeed<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">float</span></span> Speed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position <span class="token operator">!=</span> MovingLocation<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Moving<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">var</span></span> aim <span class="token operator">=</span> MovingLocation <span class="token operator">-</span> transform<span class="token punctuation">.</span>position<span class="token punctuation">;</span>
        aim<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">var</span></span> moveVec <span class="token operator">=</span> aim<span class="token punctuation">.</span>normalized <span class="token operator">*</span> Time<span class="token punctuation">.</span>deltaTime <span class="token operator">*</span> Speed<span class="token punctuation">;</span>

        Speed <span class="token operator">=</span> <span class="token function">Accelarator</span><span class="token punctuation">(</span>Speed<span class="token punctuation">,</span> MaxSpeed<span class="token punctuation">,</span> aim<span class="token punctuation">.</span>magnitude<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自己写的加速度函数</span>
        _animator<span class="token punctuation">.</span><span class="token function">SetFloat</span><span class="token punctuation">(</span>_animIDSpeed<span class="token punctuation">,</span> Speed<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name"><span class="token keyword">var</span></span> flag <span class="token operator">=</span> _controller<span class="token punctuation">.</span><span class="token function">Move</span><span class="token punctuation">(</span>moveVec<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 防止阻挡死循环</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> CollisionFlags<span class="token punctuation">.</span>CollidedSides <span class="token operator">||</span> flag <span class="token operator">==</span> CollisionFlags<span class="token punctuation">.</span>Sides<span class="token punctuation">)</span> Speed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token comment">// 防止运动超出界限</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Speed <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Moving <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    _animator<span class="token punctuation">.</span><span class="token function">SetFloat</span><span class="token punctuation">(</span>_animIDSpeed<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用NavMesh，代码简化成了：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MoveOnce</span><span class="token punctuation">(</span><span class="token class-name">Vector3</span> location<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">float</span></span> MaxSpeed<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    _navMeshAgent<span class="token punctuation">.</span>speed <span class="token operator">=</span> MaxSpeed<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
    _navMeshAgent<span class="token punctuation">.</span><span class="token function">SetDestination</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// animator里面的速度在update里面更新</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h2><p>考虑到在rimworld中表现糟糕的寻路延迟卡顿，寻路是否可以异步进行？（是因为寻路耗时，还是NavMap创造耗时？）</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,22),d={href:"https://www.youtube.com/watch?v=u2EQtrdgfNs",target:"_blank",rel:"noopener noreferrer"},u={href:"https://www.youtube.com/watch?v=p3AB_GP45C4",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://docs.unity3d.com/Packages/com.unity.ai.navigation@2.0/manual/CreateNavMesh.html",target:"_blank",rel:"noopener noreferrer"};function h(m,g){const s=o("ExternalLinkIcon");return p(),i("div",null,[r,n("ul",null,[n("li",null,[a("新版Navigation："),n("a",d,[a("New AI Navigation in Unity - Youtube"),e(s)])]),n("li",null,[a("旧版Navigation："),n("a",u,[a("Making A MOBA Character in 2023 - #1: INTRODUCTION (Unity 2023 Tutorial) - Youtube"),e(s)])]),n("li",null,[a("NavMesh实现原理："),n("a",k,[a("Navigation Meshes and Pathfinding"),e(s)])]),n("li",null,[n("a",v,[a("ai.navigation@2.0 - Unity Manual"),e(s)])])])])}const M=t(l,[["render",h],["__file","Navigation.html.vue"]]),N=JSON.parse('{"path":"/AI/Navigation.html","title":"寻路","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"游戏中的寻路算法","slug":"游戏中的寻路算法","link":"#游戏中的寻路算法","children":[]},{"level":2,"title":"Unity方案-AINavigation","slug":"unity方案-ainavigation","link":"#unity方案-ainavigation","children":[{"level":3,"title":"不同层级的碰撞","slug":"不同层级的碰撞","link":"#不同层级的碰撞","children":[]},{"level":3,"title":"运行时更新NavMesh","slug":"运行时更新navmesh","link":"#运行时更新navmesh","children":[]},{"level":3,"title":"NavMesh的使用方法","slug":"navmesh的使用方法","link":"#navmesh的使用方法","children":[]}]},{"level":2,"title":"优化","slug":"优化","link":"#优化","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1707819000000,"updatedTime":1714052224000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":2}]},"readingTime":{"minutes":2.67,"words":802},"filePathRelative":"AI/Navigation.md","localizedDate":"February 13, 2024"}');export{M as comp,N as data};
