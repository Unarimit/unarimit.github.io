import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as i,c,a as e,b as n,d as l,e as o}from"./app-BX3Xhc_b.js";const d={},u=o('<h1 id="常用语法" tabindex="-1"><a class="header-anchor" href="#常用语法"><span>常用语法</span></a></h1><p>汇总了开发常用的语法，并对比了和其他语言(C++, C#)的区别。</p><blockquote><p>&quot;解释型语言的区分并不在于源码是否被编译，而在于是否有能力（且轻易的）执行动态生成的代码&quot;</p></blockquote><h2 id="烦人的-特性" tabindex="-1"><a class="header-anchor" href="#烦人的-特性"><span>（烦人的）特性</span></a></h2><blockquote><p>和其他语言(C++, C#)不同的地方</p></blockquote><ol><li>符号可以不定义直接使用 <blockquote><p>如我打开lua console就开始<code>print(a)</code>，我会得到<code>nil</code>，而不是一个报错。</p></blockquote></li><li>数组下标从1开始，并不强求，但是很多机制都遵循这个标准 <blockquote><p>???</p></blockquote></li><li>喜欢定义标新立异的符号 <blockquote><p><code>#</code>, <code>..</code>, <code>...</code>, <code>--</code>, <code>[[]]</code>, for和while用<code>do</code>, if、else、elseif用<code>then</code></p></blockquote></li><li>动态类型</li><li>函数的丢弃规则 <blockquote><p><code>function foo(a) return &#39;a&#39; end</code><code>a, b = foo(c, d, e)</code> --可以运行哦--&gt; <code>a = &#39;a&#39; b = nil</code></p></blockquote></li><li>lua的函数并不是像C++一样的“命了名的代码块”，而更像是一种“实例” <blockquote><p>“lua只有闭包没用函数（只是为了习惯称闭包为函数），函数本身是闭包的原型” <code>function foo() {body} return</code> 是 <code>foo = function() {body} return</code> 的语法糖</p></blockquote></li><li>lua的位运算符是&quot;逻辑移位&quot;，每个移位操作都会用0填充空出的位(补码表示下) <blockquote><p>如<code>(-4) &gt;&gt; 2</code>在lua中会得到<code>4611686018427387903</code>而不是<code>-1</code></p></blockquote></li><li>在表的方法中，注意<code>.</code>和<code>:</code>的区别</li><li>没有全局变量，有“全局变量” <ul><li><code>_ENV</code> 作为“上值”（一个外部的局部变量，upvalue）的概念</li><li><code>a = 3</code> 等价于 <code>_ENV.a = 3</code></li><li>理解 <code>_ENV</code> 和 <code>_G</code> 的区别(<code>_ENV._G</code>)，如何结合元表来实现沙盒。可能从c代码上理解更方便些。</li></ul></li><li>协程这一定义比较简单，如果想要像unity里那样模拟多线程，需要对其分发执行 <ul><li>感觉lua协程就像是python中的生成器，c#中的IEnumerator</li><li>和主程序不共用一个栈</li></ul></li></ol><h2 id="基础数据类型" tabindex="-1"><a class="header-anchor" href="#基础数据类型"><span>基础数据类型</span></a></h2><p>nil, number(integer, float), boolean, string, userdata, function, thread, table</p>',8),r=e("li",null,"userdata, function, thread, table 属于引用类型，userdata还有轻量级版本（light userdata）",-1),p=e("li",null,[n("number于5.3开始区分integer和float "),e("ul",null,[e("li",null,[e("code",null,"//"),n("是整除，"),e("code",null,"%"),n("很特殊，"),e("code",null,"3.14 % 1 = 0.14")]),e("li",null,[e("code",null,'"10" + 1 --> 11.0')])])],-1),h=e("li",null,[n("长字符串声明"),e("code",null,"[[ string\\n\\rstring ]]"),n("和"),e("code",null,"\\z")],-1),k=e("code",null,"..",-1),b=e("code",null,"#",-1),m={href:"https://www.lua.org/manual/5.3/manual.html#6.4",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.lua.org/manual/5.3/manual.html#6.5",target:"_blank",rel:"noopener noreferrer"},v=o("<li>是数组、是字典还是结构体</li><li>结构体：把<code>math.sin</code>解释为“以字符串&#39;sin&#39;为键检索表<code>math</code>”</li><li>数组：小心空洞</li><li>字典：遍历键值对——<code>pairs</code>迭代器和<code>ipairs</code>(顺序)</li><li><code>foo.x ~= foo[x]</code>, <code>foo.x == foo[&#39;x&#39;]</code></li>",5),g={href:"https://www.lua.org/manual/5.3/manual.html#6.6",target:"_blank",rel:"noopener noreferrer"},_=e("li",null,"书中第5章的练习中向我们展示了lua的二义性，真出生啊",-1),q=o(`<blockquote><p>使用<code>type</code>函数可以获取值对应的类型名词，如<code>type(true) ---&gt; boolean</code></p></blockquote><h2 id="控制流长啥样" tabindex="-1"><a class="header-anchor" href="#控制流长啥样"><span>控制流长啥样</span></a></h2><h3 id="for" tabindex="-1"><a class="header-anchor" href="#for"><span>for</span></a></h3><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> N <span class="token keyword">do</span>
    <span class="token punctuation">...</span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="if" tabindex="-1"><a class="header-anchor" href="#if"><span>if</span></a></h3><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token keyword">if</span> n <span class="token operator">&gt;</span> N <span class="token keyword">then</span>
    <span class="token punctuation">...</span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="一些不同" tabindex="-1"><a class="header-anchor" href="#一些不同"><span>一些不同</span></a></h3><ul><li>使用<code>~=</code>作为不等判断</li></ul><h2 id="奇怪的符号" tabindex="-1"><a class="header-anchor" href="#奇怪的符号"><span>奇怪的符号</span></a></h2><ul><li><code>#</code>：获取字符串长度 <code>print(#&quot;hello&quot;) --&gt; 5</code>，获取table长度</li><li><code>..</code>: 链接两个字符串 <code>print(&quot;ab&quot;..&quot;cd&quot;) --&gt; abcd</code></li><li>注释使用<code>--</code>(单行)和<code>--[[ line,line ]]--</code>(多行) <ul><li><code>--[=[]=]</code></li></ul></li></ul><h2 id="分号的必要性" tabindex="-1"><a class="header-anchor" href="#分号的必要性"><span>分号的必要性</span></a></h2><blockquote><p>lua的分号是可有可无的</p></blockquote><p>我在尝试匿名函数的调用时发现了一个“有趣”的bug</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;ok&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">-- 在后面加上分号就好了</span>

<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;233&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的执行结果是<code>.\\test.lua:4: attempt to call a nil value stack traceback:</code>，很显然它识别错了语法，尝试调用<code>a()()</code>。</p><h2 id="异常处理家族" tabindex="-1"><a class="header-anchor" href="#异常处理家族"><span>异常处理家族</span></a></h2><ul><li><code>error()</code>: 类似 throw ex</li><li><code>assert()</code>：一种封装了判断功能的 throw ex</li><li><code>pcall()</code>: 实现try-catch结构</li></ul><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射"><span>反射</span></a></h2><blockquote><p>&quot;反射是程序用来检查和修改器自身某些部分的能力&quot; —— 《Lua程序设计》</p></blockquote><p>我第一次得知反射这个概念是在c#中，c#通过类的metadata（或类型对象）获取类的标签，可以通过标签实例化对象，这些行为被称为反射。</p><p>而在Lua中则有很大的不同，Lua通过调试库实现其&quot;反射&quot;概念，调试库中包含自省函数和钩子。</p><blockquote><p>&quot;自省函数（introspective function）和钩子（hook），自省函数允许我们检查一个正在运行中的程序的几个方面，例如活动函数的栈、当前正在执行的代码行、局部变量的名称和值。钩子则允许我们跟踪有一个程序的执行。&quot; —— 《Lua程序设计》</p></blockquote><p>Lua的反射（我认为）可以概括成虚拟机栈的追踪、查询和修改。在《Lua程序设计》书中，讲述了如何获取函数信息（签名），如何跨作用域修改变量（甚至上值），如何利用钩子限制外部代码的恶意行为等。但对其实现依据却不怎么描述，读起来很让人困惑。</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,24),y={href:"https://www.lua.org/pil/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.bing.com/search",target:"_blank",rel:"noopener noreferrer"},x=o('<details class="hint-container details"><summary>问问gpt lua中协程和unity中协程的区别</summary><p>Q: 我正在学习编程语言，我发现编程语言lua的协程和游戏引擎unity中的协程有很大的区别，lua的协程需要自己写控制循环才能模拟多线程，而unity的协程由于已经包装好了，可以在更新模式中直接模拟多线程。我说的对吗？</p><p>A: 你说得很对！Lua 中的协程和 Unity 中的协程之间确实存在显著的区别。</p><p>让我们来详细探讨一下这两者之间的不同之处：</p><ol><li>Lua 协程： <ul><li>Lua 中的协程是一种具有多返回点的方法，它将时间分片，但不是抢占式执行。换句话说，Lua 协程不会被主动执行类似 MoveNext 这样的操作，而是需要我们自己去主动激发执行。</li><li>Lua 协程依附于主线程执行，相当于在主线程上夺取了一定的执行时间片。它允许我们在同一帧内将运算分散到不同的帧中，从而实现流畅的体验。</li><li>在 Lua 中，我们需要自己编写控制循环来模拟多线程行为。</li></ul></li><li>Unity 协程： <ul><li>Unity 中的协程也是运行在主线程里的，它和 MonoBehaviour 的 Update 函数一样，在每一帧都会被处理。</li><li>Unity 的协程已经被包装好了，我们可以直接使用 StartCoroutine 来开启一个协程。这是我们在使用 Unity 中最常见的直观理解。</li><li>在 Unity 的协程中，我们可以执行一些异步操作，比如下载文件、加载资源等。当这些操作完成后，我们可以执行回调函数。 总之，Lua 协程和 Unity 协程虽然都涉及到协程的概念，但在实现方式和用法上存在明显的差异。感谢你的提问，希望这些解释对你有所帮助！👍</li></ul></li></ol></details>',1);function L(N,U){const a=s("ExternalLinkIcon");return i(),c("div",null,[u,e("ul",null,[r,p,e("li",null,[n("string是不变值，不能实现O(1)修改里面的某个字符，像c# "),e("ul",null,[h,e("li",null,[k,n("、"),b,n("以及"),e("a",m,[n("其他api"),l(a)])]),e("li",null,[e("a",f,[n("utf8标准库"),l(a)])])])]),e("li",null,[n("table是lua中唯一的主要的数据结构 "),e("ul",null,[v,e("li",null,[e("a",g,[n("表标准库"),l(a)]),n("：很简单 的两个小功能，双端队列都实现不了（指时间复杂度问题）")]),_])])]),q,e("ul",null,[e("li",null,[e("a",y,[n("Lua程序设计 第四版 - Roberto"),l(a)])]),e("li",null,[e("a",w,[n("Copilot - Bing"),l(a)])])]),x])}const V=t(d,[["render",L],["__file","Grammar.html.vue"]]),G=JSON.parse('{"path":"/Lua/Grammar.html","title":"常用语法","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"（烦人的）特性","slug":"烦人的-特性","link":"#烦人的-特性","children":[]},{"level":2,"title":"基础数据类型","slug":"基础数据类型","link":"#基础数据类型","children":[]},{"level":2,"title":"控制流长啥样","slug":"控制流长啥样","link":"#控制流长啥样","children":[{"level":3,"title":"for","slug":"for","link":"#for","children":[]},{"level":3,"title":"if","slug":"if","link":"#if","children":[]},{"level":3,"title":"一些不同","slug":"一些不同","link":"#一些不同","children":[]}]},{"level":2,"title":"奇怪的符号","slug":"奇怪的符号","link":"#奇怪的符号","children":[]},{"level":2,"title":"分号的必要性","slug":"分号的必要性","link":"#分号的必要性","children":[]},{"level":2,"title":"异常处理家族","slug":"异常处理家族","link":"#异常处理家族","children":[]},{"level":2,"title":"反射","slug":"反射","link":"#反射","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1707819000000,"updatedTime":1711279899000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":7}]},"readingTime":{"minutes":5.79,"words":1738},"filePathRelative":"Lua/Grammar.md","localizedDate":"February 13, 2024"}');export{V as comp,G as data};
