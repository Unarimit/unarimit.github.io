import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as r,c as o,a as e,b as a,d as t,e as c}from"./app-BX3Xhc_b.js";const s={},d=c('<h1 id="性能优化-ui篇" tabindex="-1"><a class="header-anchor" href="#性能优化-ui篇"><span>性能优化-UI篇</span></a></h1><p>UI的性能优化可以分为三个方向：</p><ol><li>减少draw call提交的次数，从而减小总I/O <ul><li>触发动态合批（dynamic batching），首先通过图集合并细小的UI，会增加一定量的CPU开销。</li><li>减少图片大小，使用平铺、非焦点图低像素等技巧。</li></ul></li><li>减少CPU计算 <ul><li>使用多个画布（平行或内嵌），实现动静分离。</li><li>非必要不使用布局（Layout）</li></ul></li><li>针对特定场景 <ul><li>对于有大量元素的列表，采用分页式设计，不加载被mask的元素。</li><li>。。。</li></ul></li></ol><p>实际实施过程中，有时为了美术效果或设计方便，往往使UI难以采用优化策略。如合批方面，当多个必要的材质在层级上混合，且由Animation在层级上控制时，就不是打个图集就能完事得的了。（理想和现实的差距）</p><p>本文将主要讨论“动态合批”和“动静分离”策略。</p><h2 id="动态合批" tabindex="-1"><a class="header-anchor" href="#动态合批"><span>动态合批</span></a></h2><p>UI的合批规则和3d物体的合批规则之间有一定的差距，而且还随unity版本不同，合批规则也有一定差距。</p><blockquote><p>由于UI动态合批的规则代码并没有公开，所以想要理解这一点更为困难。</p></blockquote><blockquote><p>对于URP管线，Canva是Screen Base：代码入口从 <code>UniversalRenderPipeline.RenderSingleCamera</code> 开始，经过 <code>ScriptableRenderer.Execute</code> 和具体的渲染Pass，就到了 <code>_Internal</code> 结尾的内部方法中了。然后偷偷的调 <code>Canvas.RenderSubBatch</code></p></blockquote><h3 id="问题-看不到源码-逻辑的判定点不明" tabindex="-1"><a class="header-anchor" href="#问题-看不到源码-逻辑的判定点不明"><span>问题：看不到源码，逻辑的判定点不明</span></a></h3><blockquote><p>入口：UniversalRenderPipeline.RenderSingleCamera -&gt; ScriptableRenderer.Execute -&gt; &quot;UGUI Render Logic&quot; -&gt; _Internal</p></blockquote><blockquote><p>CommandBuffer是渲染命令</p></blockquote><p>NGUI的DrawCall提交代码是能看的，可以根据这个参考合批做的事情和一些逻辑。</p><h3 id="动态合批-性能分析" tabindex="-1"><a class="header-anchor" href="#动态合批-性能分析"><span>动态合批-性能分析</span></a></h3><p>TODO: 分析合批前和合批后的性能。</p><h2 id="动静分离" tabindex="-1"><a class="header-anchor" href="#动静分离"><span>动静分离</span></a></h2><p>动静分离，主要用于减少CPU重建画布的开销。</p><h2 id="尝试自己写合批代码" tabindex="-1"><a class="header-anchor" href="#尝试自己写合批代码"><span>尝试自己写合批代码</span></a></h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>',19),h={href:"https://docs.unity3d.com/2021.3/Documentation/Manual/dynamic-batching.html",target:"_blank",rel:"noopener noreferrer"},p={href:"https://www.youtube.com/watch?v=D3m_pfJ1nwQ",target:"_blank",rel:"noopener noreferrer"},u={href:"https://learn.unity.com/tutorial/nested-canvas-optimization-2019-3#",target:"_blank",rel:"noopener noreferrer"},m={href:"https://unity.com/cn/how-to/unity-ui-optimization-tips",target:"_blank",rel:"noopener noreferrer"},_={href:"https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/index.html",target:"_blank",rel:"noopener noreferrer"};function f(b,U){const n=i("ExternalLinkIcon");return r(),o("div",null,[d,e("ul",null,[e("li",null,[e("a",h,[a("动态合批 - Unity Doc"),t(n)])]),e("li",null,[e("a",p,[a("嵌套画布优化 - 阿严Dev, Youtube"),t(n)]),e("ul",null,[e("li",null,[e("a",u,[a("Nested Canvas Optimization 2019.3 - Learn unity"),t(n)])]),e("li",null,[e("a",m,[a("Unity UI 优化技巧 - Unity HowTo"),t(n)])])])]),e("li",null,[e("a",_,[a("Unity UI (uGUI) 2.0 - Unity Manul"),t(n)])])])])}const I=l(s,[["render",f],["__file","PerformanceOptimizeInUI.html.vue"]]),v=JSON.parse('{"path":"/CodingRamble/PerformanceOptimizeInUI.html","title":"性能优化-UI篇","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"动态合批","slug":"动态合批","link":"#动态合批","children":[{"level":3,"title":"问题：看不到源码，逻辑的判定点不明","slug":"问题-看不到源码-逻辑的判定点不明","link":"#问题-看不到源码-逻辑的判定点不明","children":[]},{"level":3,"title":"动态合批-性能分析","slug":"动态合批-性能分析","link":"#动态合批-性能分析","children":[]}]},{"level":2,"title":"动静分离","slug":"动静分离","link":"#动静分离","children":[]},{"level":2,"title":"尝试自己写合批代码","slug":"尝试自己写合批代码","link":"#尝试自己写合批代码","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1718449179000,"updatedTime":1740898402000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":3}]},"readingTime":{"minutes":1.81,"words":544},"filePathRelative":"CodingRamble/PerformanceOptimizeInUI.md","localizedDate":"June 15, 2024"}');export{I as comp,v as data};
