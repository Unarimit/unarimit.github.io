import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as u,c as r,a as s,b as n,d as a,w as o,e}from"./app-BX3Xhc_b.js";const d="/assets/class-1-1-Dp5_500m.png",k="/assets/class-1-2-B8Utd3pY.png",m="/assets/class-2-1-CmdxPwiB.png",v="/assets/class-2-2-DJPXTJ1D.png",h="/assets/class-3-btPpnpW5.png",b="/assets/class-4-DEVvW5g5.png",_={},g=e('<h1 id="类型" tabindex="-1"><a class="header-anchor" href="#类型"><span>类型</span></a></h1><p>流行的编程语言基本都支持OOP（Object Oriented Programming, 面向对象编程），而类型是OOP的基石。类型具有封装、多态和继承特性。</p><p>在类型中，往往需要考虑以下问题：</p><ul><li>类型中的数据，如何排布在内存中 <ul><li>C++和C#的策略并不相同</li></ul></li><li>（类型的）实例如何传递给函数，其数据成员如何共享</li><li>类型如何利用虚函数实现（运行时）多态</li><li>访问控制（封装）</li><li>类型转换规则（如：int-&gt;long，derive-&gt;base）</li></ul><h2 id="类型内存安排" tabindex="-1"><a class="header-anchor" href="#类型内存安排"><span>类型内存安排</span></a></h2>',5),C={href:"https://book.douban.com/subject/34864920/",target:"_blank",rel:"noopener noreferrer"},f=s("img",{height:"200",src:d},null,-1),y=s("img",{height:"200",src:k},null,-1),w=s("p",null,"针对这种对齐策略，可以进一步修改类成员的顺序，减少内存开销：",-1),T=s("img",{height:"200",src:m},null,-1),x=s("img",{height:"200",src:v},null,-1),E=e(`<p>左边为类型详情，右边为在内存中的排布。这种策略是按照字节大小的倍数（4字节（32位）对齐4字节，1字节（8位）对齐1字节）对齐。C++中提供一些方法可以配置对齐的粒度。</p><details class="hint-container details"><summary>C++配置对齐粒度</summary><p>方法一：使用 <code>#pragma pack</code></p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>push<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">// 设置字节对齐为 1 字节，取消自动对齐</span></span>
<span class="token keyword">struct</span> <span class="token class-name">UnalignedStruct</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
    <span class="token keyword">short</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>pop<span class="token punctuation">)</span> </span><span class="token comment">// 恢复默认的字节对齐设置</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法二：使用<code>alignas</code> ( <code>alignof</code> 查询)</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token keyword">alignas</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> AlignedStruct <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    AlignedStruct a<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Alignment of AlignedStruct: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">alignof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>`,2),B=s("strong",null,"C#",-1),A=s("code",null,"unsafe",-1),P={href:"https://book.douban.com/subject/26285940",target:"_blank",rel:"noopener noreferrer"},q=e('<img src="'+h+'"><h2 id="特殊的成员函数和对象拷贝" tabindex="-1"><a class="header-anchor" href="#特殊的成员函数和对象拷贝"><span>特殊的成员函数和对象拷贝</span></a></h2><h3 id="构造函数和析构函数" tabindex="-1"><a class="header-anchor" href="#构造函数和析构函数"><span>构造函数和析构函数</span></a></h3>',3),L={href:"https://github.com/Cpp-Club/Cxx_HOPL4_zh/tree/main",target:"_blank",rel:"noopener noreferrer"},O=e(`<p>C++提出了RAII（Resource Acquisition ls Initialization，资源获取即初始化）这一理念来定义构造函数应该做的事情，以便在对象离开作用域后能正确的释放资源。</p><p>注意：</p><ul><li>构造函数会从基类开始执行</li><li>（C++）当存在虚函数时，析构函数也应该是虚函数</li></ul><h3 id="成员的初始化" tabindex="-1"><a class="header-anchor" href="#成员的初始化"><span>成员的初始化</span></a></h3><p>C++的成员初始化发生在构造函数的 <code>初始化列表</code> 中，并且按照变量的<strong>声明顺序</strong>构造，也可以内联构造，如以下代码所示：</p><blockquote><p>“内联构造”准确的说应该是：默认成员初始化器——给数据成员一个默认值，这个默认值可以被构造函数中的初始化所取代</p></blockquote><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TestClassB</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// TestClass是一个构造函数中带cout的类，用于调试这种东西</span>
    TestClass tc1 <span class="token operator">=</span> <span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 内联初始化</span>
    TestClass tc2 <span class="token operator">=</span> <span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">TestClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">tc1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 覆盖了tc1的内联初始化，应该在编译时就优化掉了</span>
    <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C#中class的成员初始化发生在构造函数的 <code>函数体</code> 中，也可以内联构造（和C++的覆盖规则不同），如以下代码所示：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">class</span> <span class="token class-name">TestClassB</span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">;</span>
    <span class="token class-name">TestClass</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TestClass</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先执行</span>
    <span class="token keyword">public</span> <span class="token function">TestClassB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 这里只能写 \`:base(xxx)\` 看来C#的开发人员不是很喜欢C++的初始化列表</span>
    <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TestClass</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 后执行</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于C#中的struct，成员初始化不可以内联构造，且在构造函数中必须为所有成员初始化。一个声明了却没有初始化的struct，其值置为“零”或null。</p>`,10),R={href:"https://book.douban.com/subject/26285940",target:"_blank",rel:"noopener noreferrer"},j=e('<p>在C#中如果在class中定义一个struct，并且不做任何显式初始化，他就会被初始为全“零”，但<strong>不会</strong>调用无参构造函数，这一点和C++有很大的区别。</p><p>特别的，对于<strong>静态成员变量</strong>。C++在全局作用域中初始它们，C#则在“类型对象”的实例化时初始它们。</p><h3 id="拷贝-c-复杂的拷贝控制函数" tabindex="-1"><a class="header-anchor" href="#拷贝-c-复杂的拷贝控制函数"><span>拷贝-C++：复杂的拷贝控制函数</span></a></h3><p>C++的拷贝控制函数有哪些呢？</p><ul><li>拷贝构造函数</li><li>拷贝赋值函数</li><li>移动拷贝构造函数</li><li>移动拷贝赋值函数</li><li>析构函数</li></ul><p>可以看出C++的拷贝控制是相当复杂的，有5个可用于拷贝控制的函数。其中“移动”开头的函数需要结合“移动语义”去理解。在实现类的时候一般需要遵循“三五原则”，即考虑移动语义，实现五个，不考虑移动语义，则实现三个。</p>',6),I={href:"https://github.com/Cpp-Club/Cxx_HOPL4_zh/blob/main/04.md#423-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89",target:"_blank",rel:"noopener noreferrer"},S=s("code",null,"std::move()",-1),D=s("code",null,"std::forward<T>()",-1),z=s("code",null,"T&&",-1),F=s("li",null,[s("code",null,"std::move()"),n("：将一个任意类型"),s("code",null,"static_cast"),n("成一个右值引用并返回，表示移动语义")],-1),H=s("li",null,[s("code",null,"std::forward<T>()"),n("：用于保留函数实参的语义，若为右值则是移动语义。通常被称为完美转发。")],-1),M=s("code",null,"T&&",-1),W=s("li",null,[n("作为确定类型的形参时（如 "),s("code",null,"int&&"),n("），只接受右值实参（临时量或转化成的）。")],-1),N=s("strong",null,"引用折叠",-1),V=s("code",null,"T&&",-1),J=s("code",null,"T&",-1),U=s("code",null,"const T&",-1),K=s("code",null,"const T&",-1),X=s("code",null,"T&&",-1),Y=s("code",null,"vector<T>",-1),G=s("li",null,[n("作为实参时，实际上是一个左值，但具有右值的“潜质”（可以被 "),s("code",null,"std::forward<T>()"),n(" “激活”移动语义）")],-1),Q=e(`<details class="hint-container details"><summary>简单的测试类</summary><p>以下代码展示了一个简单的拷贝控制测试类</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TestClass</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 构造函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ctor call&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> TestClass<span class="token operator">&amp;</span> foo<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 拷贝构造函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;copy call&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">TestClass</span><span class="token punctuation">(</span>TestClass<span class="token operator">&amp;&amp;</span> foo<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token comment">// 移动拷贝构造函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;move copy call&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    TestClass<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> TestClass<span class="token operator">&amp;</span> foo<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 拷贝赋值函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;assign call&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    TestClass<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>TestClass<span class="token operator">&amp;&amp;</span> foo<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">{</span> <span class="token comment">// 移动拷贝赋值函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;move assign call&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 析构函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;finalize call&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="hint-container details"><summary>测试移动语义</summary><p><code>TestClass</code>是一个拥有拷贝构造函数和移动拷贝构造函数的类，下面代码中，哪些会调用该类的移动拷贝构造函数？</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    TestClass<span class="token operator">&amp;&amp;</span> t1 <span class="token operator">=</span> <span class="token function">TestClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    TestClass t2 <span class="token operator">=</span> t1<span class="token punctuation">;</span> <span class="token comment">// 拷贝构造函数</span>
    TestClass t3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>TestClass<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动拷贝构造函数</span>
    TestClass t4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动拷贝构造函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>`,2),Z={href:"https://book.douban.com/subject/10505113/",target:"_blank",rel:"noopener noreferrer"},$=e('<p>除此之外，还需注意：</p><ul><li>隐式转换的影响和explict <ul><li>如 <code>Myclass a = 5;</code> 可能是 <code>Myclass</code> 类有类似 <code>Myclass(int a)</code> 的构造函数，int字面量 <code>5</code> 先被隐式转换成了 <code>Myclass</code>。可以改成 <code>explicit Myclass(int a)</code> 避免隐式转换。</li></ul></li></ul><h3 id="拷贝-c-class和struct的区别" tabindex="-1"><a class="header-anchor" href="#拷贝-c-class和struct的区别"><span>拷贝-C#：Class和Struct的区别</span></a></h3><p>WIP</p><h2 id="虚函数的管理方法" tabindex="-1"><a class="header-anchor" href="#虚函数的管理方法"><span>虚函数的管理方法</span></a></h2><p>为了实现运行时多态，运行中需要知道对象准确的类型。</p><h3 id="c-虚表和rtti" tabindex="-1"><a class="header-anchor" href="#c-虚表和rtti"><span>C++：虚表和RTTI</span></a></h3><p>C++使用虚表解决运行时访问虚函数的问题（有虚函数的类才有虚表），用户也可以通过RTTI（Runtime Type Identification，执行期类型识别）获取对象的真实类型。</p>',8),ss={href:"https://csguide.cn/cpp/object_oriented/virtual_function.html#c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"},ns=e(`<details class="hint-container details"><summary>《深度探索C++对象模型》所示的虚表</summary><p>下列代码定义了一个类</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">float</span> xval<span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">float</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">,</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">PointCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> ostream<span class="token operator">&amp;</span> <span class="token function">print</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>os<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
	<span class="token keyword">float</span> _x<span class="token punctuation">;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> _point_count<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它对应的模型：</p><img src="`+b+`"></details><p>除此之外，还需注意：</p><ul><li>C++的多继承和菱形继承问题</li><li>若想通过虚表访问虚函数（动态绑定），必须是从有继承关系的对象指针或引用调用虚函数。 <ul><li>总之编译器会检查，不会把不需要动态绑定的调用编译成访问虚表的版本</li></ul></li></ul><h3 id="c-类型对象" tabindex="-1"><a class="header-anchor" href="#c-类型对象"><span>C#：类型对象</span></a></h3><p>WIP</p><h3 id="抽象类和接口" tabindex="-1"><a class="header-anchor" href="#抽象类和接口"><span>抽象类和接口</span></a></h3><p>WIP</p><h2 id="访问控制" tabindex="-1"><a class="header-anchor" href="#访问控制"><span>访问控制</span></a></h2><p>这个话题由于牵扯到工程问题，会比较复杂。先以关键字为出发点简单涉及一下：</p><ul><li>成员的private, public, protected</li><li>C++继承时还分public继承、private继承和protected继承。</li><li>C#由于全都是类，则类的private, public, protected用来限制访问域 <ul><li>还有internal，sealed，static，abstract，partial关键字</li></ul></li></ul><p>C++的b友元是谁想出来的？</p><h2 id="类型转换" tabindex="-1"><a class="header-anchor" href="#类型转换"><span>类型转换</span></a></h2><h3 id="c-static-cast、reinterpret-cast、const-cast-和-dynamic-cast" tabindex="-1"><a class="header-anchor" href="#c-static-cast、reinterpret-cast、const-cast-和-dynamic-cast"><span>C++：static_cast、reinterpret_cast、const_cast 和 dynamic_cast</span></a></h3><p>这些类型转换函数消除了 C 风格的类型转换 <code>()</code> 中的二义性，其中：</p><ul><li><code>static_cast</code> 用于非多态类型的转换，一般用于转换数值数据类型，最好不要于指针的转换。 <ul><li>*对于值转换，会调用含转换前值的新类型的构造函数</li></ul></li><li><code>dynamic_cast</code> 用于<strong>多态</strong>类型的转换，只适用于指针或引用，执行运行时类型检查 <ul><li>很像C#和Java编程语言中的类型转换</li><li>相当安全，但检测也会消耗时间</li></ul></li><li><code>const_cast</code> 用于删除 const、volatile 和 __unaligned 特性。</li><li><code>reinterpret_cast</code> 用于位的简单重新解释，没事不要用这个。</li></ul><p>*<code>static_cast</code>的值转换：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TestClassA</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">TestClassB</span><span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">TestClassB</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
     <span class="token keyword">auto</span> b1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>TestClassA<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译失败</span>
     <span class="token keyword">auto</span> b2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>TestClassB<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK，因为存在这样的构造函数</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="c-is、as和类型安全" tabindex="-1"><a class="header-anchor" href="#c-is、as和类型安全"><span>C#：is、as和类型安全</span></a></h3><p>C#也支持 C 风格的类型转换 <code>()</code></p><p>WIP</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,21),as={href:"https://book.douban.com/subject/34864920/",target:"_blank",rel:"noopener noreferrer"},ts=s("ul",null,[s("li",null,"3.2.5.1 C/C++的数据、代码和内存/对齐和包裹")],-1),es={href:"https://csguide.cn/cpp/basics/byte_alignment.html#%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99",target:"_blank",rel:"noopener noreferrer"},ps={href:"https://book.douban.com/subject/26285940",target:"_blank",rel:"noopener noreferrer"},os=s("ul",null,[s("li",null,"5.2 引用类型和值类型"),s("li",null,"8.2 实例构造器和结构（值类型）")],-1),ls={href:"https://github.com/Cpp-Club/Cxx_HOPL4_zh/tree/main",target:"_blank",rel:"noopener noreferrer"},cs={href:"https://book.douban.com/subject/10505113/",target:"_blank",rel:"noopener noreferrer"},is=s("ul",null,[s("li",null,"16.2.5 模板实参推断和引用（这里介绍了引用折叠）")],-1),us={href:"https://csguide.cn/cpp/object_oriented/virtual_function.html#c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"},rs={href:"https://github.com/huihut/interview/blob/master/README.md#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6",target:"_blank",rel:"noopener noreferrer"},ds={href:"https://book.douban.com/subject/10427315/",target:"_blank",rel:"noopener noreferrer"};function ks(ms,vs){const t=p("ExternalLinkIcon"),l=p("center"),c=p("RouteLink");return u(),r("div",null,[g,s("p",null,[n("为了加速内存的读取（可能和内存读写的最小单位有关），类型中的数据往往会被施以内存对齐策略。"),s("a",C,[n("《游戏引擎架构 第2版》"),a(t)]),n("中，就给出了C++中的一种默认对齐策略：")]),a(l,null,{default:o(()=>[f,n(),y]),_:1}),w,a(l,null,{default:o(()=>[T,n(),x]),_:1}),E,s("p",null,[n("而对于"),B,n("，由于堆内存已经被托管，且指针被设为 "),A,n("，除了对齐策略外，还有再排序策略（对class默认启用该策略，对struct默认不启用该策略）。"),s("a",P,[n("《CLR via C# 第四版》"),a(t)]),n("第110页已经给出了详尽的解释：")]),q,s("blockquote",null,[s("p",null,[n('"我立即添加了构造函数和析构函数。它们当时非常新颖，但从我的计算机架构和操作系统背景来看，我认为它们也不算很新奇，因为我需要一个机制来建立一个工作环境（构造函数）和一个逆操作来释放运行期获得的资源（析构函数）" —— '),s("a",L,[n("《HOPL4 C++》，Bjarne Stroustrup"),a(t)])])]),O,s("blockquote",null,[s("p",null,[n('"值类型（struct）构造器的工作方式与引用类型（class）的构造器截然不同。CLR总是允许创建值类型的实例，并且没有办法阻止值类型的实例化。" - '),s("a",R,[n("《CLR via C# 第四版》"),a(t)]),n(" 8.2章")])]),j,s("p",null,[n("对于移动语义（和右值引用），它的提出用于解决某种情况下指针的滥用问题，在"),s("a",I,[n("《HOPL4 C++》4.2.3 移动语义"),a(t)]),n("中就设计层面已给出了详细的解释。详细理解移动语义需要考虑 "),S,n("、"),D,n("、"),z,n(" 的使用和意义：")]),s("ul",null,[F,H,s("li",null,[M,s("ul",null,[W,s("li",null,[n("作为模板形参时，因为模板形参的"),N,n("规则，表示“万能引用”，即可以根据实参自行推断出 "),V,n("、"),J,n("、"),U,n("（当存在重载版本，且该类型为"),K,n("时，按照匹配优先级，"),X,n("将只匹配右值(移动语义)，可以参考"),a(c,{to:"/Language/Template.html#%E8%AF%95%E5%86%99-vector-t"},{default:o(()=>[Y,n(" 的实现")]),_:1}),n("）。")]),G])])]),Q,s("p",null,[n("在拷贝控制函数中，主要关注“像值的类”和“像指针的类”的处理。在"),s("a",Z,[n("《C++ Primer 第五版》"),a(t)]),n("第13章拷贝控制中，已给出详尽的解释。进一步，可以结合容器类的设计去理解这一过程。")]),$,s("p",null,[n("其中虚表地址在对象指针指向第一个的位置。在"),s("a",ss,[n("C++ 虚函数表 - 编程指北"),a(t)]),n("中，按地址访问了这些虚函数。")]),ns,s("ul",null,[s("li",null,[s("a",as,[n("《游戏引擎架构 第2版》"),a(t)]),ts]),s("li",null,[s("a",es,[n("C++字节对齐 - 编程指北"),a(t)])]),s("li",null,[s("a",ps,[n("《CLR via C# 第四版》"),a(t)]),os]),s("li",null,[s("a",ls,[n("《HOPL4 C++》，Bjarne Stroustrup"),a(t)])]),s("li",null,[s("a",cs,[n("《C++ Primer 第五版》"),a(t)]),is]),s("li",null,[s("a",us,[n("C++ 虚函数表 - 编程指北"),a(t)])]),s("li",null,[s("a",rs,[n("强制类型转换运算符的说明 - C++面试问题，作者：huihui，github"),a(t)])]),s("li",null,[n("拓展（好像是设计思想）："),s("a",ds,[n("《深度探索C++对象模型》[美] Stanley B. Lippman，侯捷译"),a(t)])])])])}const _s=i(_,[["render",ks],["__file","Class.html.vue"]]),gs=JSON.parse('{"path":"/Language/Class.html","title":"类型","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"类型内存安排","slug":"类型内存安排","link":"#类型内存安排","children":[]},{"level":2,"title":"特殊的成员函数和对象拷贝","slug":"特殊的成员函数和对象拷贝","link":"#特殊的成员函数和对象拷贝","children":[{"level":3,"title":"构造函数和析构函数","slug":"构造函数和析构函数","link":"#构造函数和析构函数","children":[]},{"level":3,"title":"成员的初始化","slug":"成员的初始化","link":"#成员的初始化","children":[]},{"level":3,"title":"拷贝-C++：复杂的拷贝控制函数","slug":"拷贝-c-复杂的拷贝控制函数","link":"#拷贝-c-复杂的拷贝控制函数","children":[]},{"level":3,"title":"拷贝-C#：Class和Struct的区别","slug":"拷贝-c-class和struct的区别","link":"#拷贝-c-class和struct的区别","children":[]}]},{"level":2,"title":"虚函数的管理方法","slug":"虚函数的管理方法","link":"#虚函数的管理方法","children":[{"level":3,"title":"C++：虚表和RTTI","slug":"c-虚表和rtti","link":"#c-虚表和rtti","children":[]},{"level":3,"title":"C#：类型对象","slug":"c-类型对象","link":"#c-类型对象","children":[]},{"level":3,"title":"抽象类和接口","slug":"抽象类和接口","link":"#抽象类和接口","children":[]}]},{"level":2,"title":"访问控制","slug":"访问控制","link":"#访问控制","children":[]},{"level":2,"title":"类型转换","slug":"类型转换","link":"#类型转换","children":[{"level":3,"title":"C++：static_cast、reinterpret_cast、const_cast 和 dynamic_cast","slug":"c-static-cast、reinterpret-cast、const-cast-和-dynamic-cast","link":"#c-static-cast、reinterpret-cast、const-cast-和-dynamic-cast","children":[]},{"level":3,"title":"C#：is、as和类型安全","slug":"c-is、as和类型安全","link":"#c-is、as和类型安全","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1713028097000,"updatedTime":1714294586000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":8}]},"readingTime":{"minutes":9.62,"words":2886},"filePathRelative":"Language/Class.md","localizedDate":"April 13, 2024"}');export{_s as comp,gs as data};
