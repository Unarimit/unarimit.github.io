import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as c,c as o,a as n,b as s,d as l,e as a}from"./app-BX3Xhc_b.js";const i={},u=a('<h1 id="一些-有趣-的问题" tabindex="-1"><a class="header-anchor" href="#一些-有趣-的问题"><span>一些“有趣”的问题</span></a></h1><p>一部分是从网上找到的问题，一部分来自我面试、笔试时遇到的问题</p><h2 id="c" tabindex="-1"><a class="header-anchor" href="#c"><span>C++</span></a></h2><h3 id="常规八股" tabindex="-1"><a class="header-anchor" href="#常规八股"><span>常规八股</span></a></h3><ol><li>malloc和free，new和delete</li></ol><p>malloc和free是c标准库函数，new和malloc在内存分配空间的差异，返回值的差异等..</p><p>new和delete分别会调用构造、析构函数。</p>',7),r={href:"https://blog.csdn.net/Dr_Cassie/article/details/96494444",target:"_blank",rel:"noopener noreferrer"},d=a(`<h3 id="类设计" tabindex="-1"><a class="header-anchor" href="#类设计"><span>类设计</span></a></h3><ol><li>以下代码哪些地方有问题</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">get_p</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    string<span class="token operator">&amp;</span> <span class="token function">get_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> s<span class="token punctuation">;</span> <span class="token comment">// 这里不行</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    string s<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>考察类的const方法</p><ol start="2"><li>虚函数和隐藏</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">testHide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">testVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">testHide2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">testHide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 隐藏了A中的函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">testVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 建议补上override或final增加可读性</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">testHide2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 隐藏了A中的函数</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实这个概念凭直觉大概率能猜对。另外还可以引申出一些其他问题，如B如何调用被隐藏的A方法。</p><h3 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h3><ol><li>以下代码在32位编译环境下的输出结果</li></ol><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span><span class="token operator">*</span> fixed<span class="token punctuation">;</span>
    <span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    A a<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>arr <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>考察对内存安排和指针（数组）的理解</p><ol start="2"><li>除了递归还有什么情况会导致栈溢出</li></ol><p>分配一个足够大的数组，因为定长数组是在栈上分配的，如下方代码所示</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">600000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顺便说一下C#的数组是分配在堆上的，无论定长还是不定长。</p><h3 id="static关键字" tabindex="-1"><a class="header-anchor" href="#static关键字"><span>static关键字</span></a></h3><ol><li>静态变量 C++的静态变量是在没有实际的cpp开发经验的话，很容易忽略的一个点。</li></ol><ul><li>（函数内）局部静态变量在函数第一次调用时执行到定义语句时执行。</li><li>（类内）成员静态变量需要在全局作用域显示定义之后才可以使用，否则在编译时就会报未定义错误。所以可以将成员静态变量当作全局静态变量来看，在程序开始执行时初始化。</li></ul><blockquote><p>顺便说一下，C#只有成员静态变量一说（没有局部静态变量，即不能在函数里定义静态变量），且在 <code>类型对象</code> 第一次初始化时初始化成员静态变量。</p></blockquote><ol start="2"><li>静态函数 表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为static。</li></ol><h3 id="模板" tabindex="-1"><a class="header-anchor" href="#模板"><span>模板</span></a></h3><ol><li>模板和静态成员</li></ol><p><code>Foo&lt;int&gt;::cnt</code>成员的初始化和实例化分别发生在下方代码的哪个地方？</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
    T data<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> Foo<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>cnt <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="c-1" tabindex="-1"><a class="header-anchor" href="#c-1"><span>C#</span></a></h2><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h3><ol><li>如何避免struct在函数中传参时的装箱</li></ol><p>利用泛型函数，或提前装好箱再传，下面是一个利用泛型函数的例子</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token keyword">interface</span> <span class="token class-name">ITest</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token class-name">StructA</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ITest</span></span>
<span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token generic-method"><span class="token function">Test</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token class-name">T</span> a<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">T</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token keyword">struct</span><span class="token punctuation">,</span> <span class="token class-name">ITest</span></span> <span class="token comment">// 这里可以进一步用in修饰，减少值类型拷贝的开销。</span>
    <span class="token punctuation">{</span>
        a<span class="token punctuation">.</span><span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Test2</span><span class="token punctuation">(</span><span class="token class-name">StructA</span> a<span class="token punctuation">)</span> <span class="token comment">// 这里是入口！</span>
    <span class="token punctuation">{</span>
        <span class="token function">Test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要明确的是，将struct转化为一个interface必定会发生装箱，但使用泛型（将泛型约束到接口）却不会。是因为在调用时JIT会生成<code>Test(StructA a)</code>的代码。</p><h3 id="内存管理-1" tabindex="-1"><a class="header-anchor" href="#内存管理-1"><span>内存管理</span></a></h3><ol><li>unsafe指针为什么不能长期持有</li></ol><p>GC的影响（回收和压缩），以及 <code>fixed</code> 关键字（C# Essential中有提及）</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>`,34);function k(v,m){const t=p("ExternalLinkIcon");return c(),o("div",null,[u,n("p",null,[s("可以看看："),n("a",r,[s("new和malloc的区别 - Dr_Cassie CSDN"),l(t)])]),d])}const g=e(i,[["render",k],["__file","Questions.html.vue"]]),y=JSON.parse('{"path":"/Language/Questions.html","title":"一些“有趣”的问题","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"C++","slug":"c","link":"#c","children":[{"level":3,"title":"常规八股","slug":"常规八股","link":"#常规八股","children":[]},{"level":3,"title":"类设计","slug":"类设计","link":"#类设计","children":[]},{"level":3,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[]},{"level":3,"title":"static关键字","slug":"static关键字","link":"#static关键字","children":[]},{"level":3,"title":"模板","slug":"模板","link":"#模板","children":[]}]},{"level":2,"title":"C#","slug":"c-1","link":"#c-1","children":[{"level":3,"title":"函数","slug":"函数","link":"#函数","children":[]},{"level":3,"title":"内存管理","slug":"内存管理-1","link":"#内存管理-1","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1711807980000,"updatedTime":1713184298000,"contributors":[{"name":"Unarimit","email":"1798907875@qq.com","commits":6}]},"readingTime":{"minutes":3.1,"words":930},"filePathRelative":"Language/Questions.md","localizedDate":"March 30, 2024"}');export{g as comp,y as data};
