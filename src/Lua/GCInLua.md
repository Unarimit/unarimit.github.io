# Lua中的GC

Lua中的内存管理类似于C#，也是托管式的，所以有垃圾回收机制，Lua垃圾回收的对象是**表和闭包**。

> 一直到Lua5.0：使用标记-清除式垃圾收集器，就好像不分代的C# GC一样，每次从根开始遍历一遍，回收被标记的内存。（它怎么没提到碎片整理啊？不会没有吧？不会吧？）

> Lua5.1：使用增量式垃圾收集器

> Lua5.2：引入紧急垃圾回收

> Lua5.4：引入了基于代的垃圾回收机制，可以在它和增量式垃圾收集器之间选择

Lua引入了一些机制管理垃圾回收策略，这些机制是：
- 弱引用表：利用表的元字段 `__mode`，有三种模式（ `v`, `k`, `kv` ）。
    > 书中举了一个把弱引用表当cache使用的例子，好抽象啊
- 析构器：在内存被回收时调用，可以用它释放外部资源。通过元方法`__gc`实现，回收时可存在“复苏”现象。
- `collectgarbage` 函数: 可以填入两个参数，具体含义见API说明。调用方式如 `collectgarbage("stop")` 和`collectgarbage("step", n)`

## 值得注意的使用方法

1. 全局变量的释放方法

通过将全局变量设为 `null`，不引用它，就可以被垃圾回收标记了（如果没有其他的引用的话）

2. 在为表设置元表时，就决定了表是否可以被析构（即调用`__gc`）

在设置后再修改元表，为其增加`__gc`元方法是没有用的

3. 使用弱引用键表优化对偶表示

目的是解决垃圾回收问题

> 我的建议是不要使用对偶表示，什么鬼特性，不能惯着（

4. 弱引用键表的 `v`(`(k, v)`模式) 引用 `k` 时，不算做强引用

一种名为“瞬表(Ephemeron Table)”的特殊情况，避免环造成的“错误”逻辑造成垃圾回收机制的失效


## 参考
- [Lua程序设计 第四版 - Roberto](https://www.lua.org/pil/)
    - 23章，垃圾收集