# 其他特性

这里将列举一些编程语言的其他特性，它们不如那些单独开章节的特性那样基础和常用，故只做简单的介绍（我自己了解的也不深）。

## 协程

> "协程提供了一种协作式多任务模型，比使用线程或进程要高效得多。" 
<br> "C++20 协程的历史始于 Niklas Gustafsson（微软）关于“可恢复函数”的提案 [Gustafsson 2012]。" <br> <div style="text-align: right;"> —— [C++20：方向之争 - Cxx_HOPL4, Github](https://github.com/Cpp-Club/Cxx_HOPL4_zh/blob/main/09.md) </div>

我认为对协程最好的解释是“可恢复函数”，虽然实现时需要保存状态信息（栈帧）使得它更像一个对象而并非函数。这里从**作用**和**设计**两个角度描述它。

协程可以用于：异步IO处理，延时任务，步长GC，生成器/迭代器（在python和科学运算领域很常见）

协程按设计可以分为：有栈协程和无栈协程，有栈协程比无栈协程更通用（但速度较慢）[参考：Cxx_HOPL4]。
> 有栈协程和无栈协程的区别主要在于协程的执行栈是由谁分配和管理的。在有栈协程中，操作系统为每个协程分配一个固定大小的栈空间，由协程自己管理和使用。在无栈协程中，协程的执行栈是动态分配的，可以在运行时根据需要进行扩展或收缩，也可以与其他协程共享同一个栈空间。

- 无栈协程：C#中的 `async/await` 设计可以看作一种无栈协程，该类设计被称为一种“编译器魔法”。这类设计将函数转化为状态机，局部变量变为状态机对象的字段。通过状态机的状态来满足“可恢复”这一特性。（可以参考[《CLR via C# 第四版》](https://book.douban.com/subject/26285940)的第28.3节）
- 有栈协程：而反观有栈协程，更像是一种在用户态模拟的线程，同样以栈的方式存储其嵌套调用的函数信息，通过完整的调用栈来满足“可恢复”这一特性。

我的理解：从定义上看感觉有栈协程的调度更简单些，有栈协程因为有调用栈，随时都可以暂停，而无栈协程要等到它运行到下一个状态才可以。相对的，有栈协程每次调度都需要将上下文切换到调用栈，调用栈的大小肯定是比单个状态大很多的。

## 闭包

## lambda

## 反射

## 模块化
C#：程序集（Assembly）

C++：C++20的import

## *AppDomain

## 参考
- [C++20：方向之争 - Cxx_HOPL4, Github](https://github.com/Cpp-Club/Cxx_HOPL4_zh/blob/main/09.md)
    - 3.2 协程
- [有栈协程与无栈协程 - 李明亮等100万人，知乎](https://zhuanlan.zhihu.com/p/330606651)
- [《CLR via C# 第四版》](https://book.douban.com/subject/26285940)
    - 28.3 编译器如何将异步函数转换成状态机